

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trimesh.scene package &mdash; trimesh 2.37.24 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="trimesh.resources package" href="trimesh.resources.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> trimesh
          

          
          </a>

          
            
            
              <div class="version">
                2.37.24
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Advanced Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Module Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="trimesh.html">trimesh package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="trimesh.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="trimesh.exchange.html">trimesh.exchange package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">trimesh.scene package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.viewer.html">trimesh.viewer package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.visual.html">trimesh.visual package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.base">trimesh.base module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.boolean">trimesh.boolean module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.bounds">trimesh.bounds module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.caching">trimesh.caching module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.collision">trimesh.collision module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.comparison">trimesh.comparison module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.constants">trimesh.constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.convex">trimesh.convex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.creation">trimesh.creation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.curvature">trimesh.curvature module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.decomposition">trimesh.decomposition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.geometry">trimesh.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.graph">trimesh.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.grouping">trimesh.grouping module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.inertia">trimesh.inertia module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.integrate">trimesh.integrate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.intersections">trimesh.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.interval">trimesh.interval module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.nsphere">trimesh.nsphere module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.parent">trimesh.parent module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.permutate">trimesh.permutate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.points">trimesh.points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.poses">trimesh.poses module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.primitives">trimesh.primitives module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.proximity">trimesh.proximity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.registration">trimesh.registration module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.remesh">trimesh.remesh module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.rendering">trimesh.rendering module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.repair">trimesh.repair module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.sample">trimesh.sample module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.smoothing">trimesh.smoothing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.transformations">trimesh.transformations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.triangles">trimesh.triangles module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.units">trimesh.units module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.util">trimesh.util module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.version">trimesh.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh.voxel">trimesh.voxel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.html#module-trimesh">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">trimesh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Module Reference</a> &raquo;</li>
        
          <li><a href="trimesh.html">trimesh package</a> &raquo;</li>
        
      <li>trimesh.scene package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/trimesh.scene.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trimesh-scene-package">
<h1>trimesh.scene package<a class="headerlink" href="#trimesh-scene-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.scene.cameras">
<span id="trimesh-scene-cameras-module"></span><h2>trimesh.scene.cameras module<a class="headerlink" href="#module-trimesh.scene.cameras" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.scene.cameras.Camera">
<em class="property">class </em><code class="descclassname">trimesh.scene.cameras.</code><code class="descname">Camera</code><span class="sig-paren">(</span><em>name=None</em>, <em>resolution=None</em>, <em>focal=None</em>, <em>fov=None</em>, <em>scene=None</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.cameras.Camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.cameras.Camera.K" title="trimesh.scene.cameras.Camera.K"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K</span></code></a></dt><dd><p>Get the intrinsic matrix for the Camera object.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.cameras.Camera.focal" title="trimesh.scene.cameras.Camera.focal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">focal</span></code></a></dt><dd><p>Get the focal length in pixels for the camera.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.cameras.Camera.fov" title="trimesh.scene.cameras.Camera.fov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fov</span></code></a></dt><dd><p>Get the field of view in degrees.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.cameras.Camera.resolution" title="trimesh.scene.cameras.Camera.resolution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resolution</span></code></a></dt><dd><p>Get the camera resolution in pixels.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.cameras.Camera.transform" title="trimesh.scene.cameras.Camera.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a></dt><dd><p>Get the (4, 4) homogenous transformation from the world frame to this camera object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.cameras.Camera.to_rays" title="trimesh.scene.cameras.Camera.to_rays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_rays</span></code></a>()</p></td>
<td><p>Convert a trimesh.scene.Camera object to ray origins and direction vectors.</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.scene.cameras.Camera.K">
<code class="descname">K</code><a class="headerlink" href="#trimesh.scene.cameras.Camera.K" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the intrinsic matrix for the Camera object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>K</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Intrinsic matrix for camera</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.cameras.Camera.focal">
<code class="descname">focal</code><a class="headerlink" href="#trimesh.scene.cameras.Camera.focal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the focal length in pixels for the camera.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>focal</strong><span class="classifier">(2,) float</span></dt><dd><p>Focal length in pixels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.cameras.Camera.fov">
<code class="descname">fov</code><a class="headerlink" href="#trimesh.scene.cameras.Camera.fov" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the field of view in degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fov</strong><span class="classifier">(2,) float</span></dt><dd><p>XY field of view in degrees</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.cameras.Camera.resolution">
<code class="descname">resolution</code><a class="headerlink" href="#trimesh.scene.cameras.Camera.resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the camera resolution in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>resolution (2,) float</strong></dt><dd><p>Camera resolution in pixels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.cameras.Camera.to_rays">
<code class="descname">to_rays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.cameras.Camera.to_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a trimesh.scene.Camera object to ray origins
and direction vectors. Will return one ray per pixel,
as set in camera.resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>origins</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Ray origins in space</p>
</dd>
<dt><strong>vectors</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Ray direction unit vectors</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(n, 2) float</span></dt><dd><p>Ray spherical coordinate angles in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.cameras.Camera.transform">
<code class="descname">transform</code><a class="headerlink" href="#trimesh.scene.cameras.Camera.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the (4, 4) homogenous transformation from the
world frame to this camera object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transform from world to camera</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.scene.cameras.camera_to_rays">
<code class="descclassname">trimesh.scene.cameras.</code><code class="descname">camera_to_rays</code><span class="sig-paren">(</span><em>camera</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.cameras.camera_to_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a trimesh.scene.Camera object to ray origins
and direction vectors. Will return one ray per pixel,
as set in camera.resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>camera</strong><span class="classifier">trimesh.scene.Camera</span></dt><dd><p>Camera with transform defined</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>origins</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Ray origins in space</p>
</dd>
<dt><strong>vectors</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Ray direction unit vectors</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(n, 2) float</span></dt><dd><p>Ray spherical coordinate angles in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.scene.cameras.look_at">
<code class="descclassname">trimesh.scene.cameras.</code><code class="descname">look_at</code><span class="sig-paren">(</span><em>points</em>, <em>fov</em>, <em>rotation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.cameras.look_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate transform for a camera to keep a list
of points in the camera’s field of view.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>fov</strong><span class="classifier">(2,) float</span></dt><dd><p>Field of view, in DEGREES</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">None, or (4, 4) float</span></dt><dd><p>Rotation matrix for initial rotation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transformation matrix with points in view</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.scene.lighting">
<span id="trimesh-scene-lighting-module"></span><h2>trimesh.scene.lighting module<a class="headerlink" href="#module-trimesh.scene.lighting" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lighting-py">
<h3>lighting.py<a class="headerlink" href="#lighting-py" title="Permalink to this headline">¶</a></h3>
<p>Hold basic information about lights.</p>
<p>Forked from the light model in <cite>pyrender</cite>:
<a class="reference external" href="https://github.com/mmatl/pyrender">https://github.com/mmatl/pyrender</a></p>
<dl class="class">
<dt id="trimesh.scene.lighting.DirectionalLight">
<em class="property">class </em><code class="descclassname">trimesh.scene.lighting.</code><code class="descname">DirectionalLight</code><span class="sig-paren">(</span><em>name=None</em>, <em>color=None</em>, <em>intensity=None</em>, <em>radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.lighting.DirectionalLight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.scene.lighting.Light" title="trimesh.scene.lighting.Light"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.scene.lighting.Light</span></code></a></p>
<p>Directional lights are light sources that act as though they are
infinitely far away and emit light in the direction of the local -z axis.
This light type inherits the orientation of the node that it belongs to;
position and scale are ignored except for their effect on the inherited
node orientation. Because it is at an infinite distance, the light is
not attenuated. Its intensity is defined in lumens per metre squared,
or lux (lm/m2).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the light.</p>
</dd>
<dt><strong>color</strong><span class="classifier">(4,) unit8</span></dt><dd><p>RGBA value for the light’s color in linear space.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">float</span></dt><dd><p>Brightness of light. The units that this is defined in depend on the type of light.
point and spot lights use luminous intensity in candela (lm/sr),
while directional lights use illuminance in lux (lm/m2).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Cutoff distance at which light’s intensity may be considered to
have reached zero. Supported only for point and spot lights, must be &gt; 0.
If None, the radius is assumed to be infinite.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="trimesh.scene.lighting.Light">
<em class="property">class </em><code class="descclassname">trimesh.scene.lighting.</code><code class="descname">Light</code><span class="sig-paren">(</span><em>name=None</em>, <em>color=None</em>, <em>intensity=None</em>, <em>radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.lighting.Light" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Base class for all light objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the light.</p>
</dd>
<dt><strong>color</strong><span class="classifier">(4,) uint8</span></dt><dd><p>RGBA value for the light’s color in linear space.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">float</span></dt><dd><p>Brightness of light. The units that this is defined in depend
on the type of light: point and spot lights use luminous intensity
in candela (lm/sr) while directional lights use illuminance
in lux (lm/m2).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Cutoff distance at which light’s intensity may be considered to
have reached zero. Supported only for point and spot lights
Must be &gt; 0.0
If None, the radius is assumed to be infinite.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="trimesh.scene.lighting.Light.color">
<code class="descname">color</code><a class="headerlink" href="#trimesh.scene.lighting.Light.color" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.lighting.Light.intensity">
<code class="descname">intensity</code><a class="headerlink" href="#trimesh.scene.lighting.Light.intensity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.lighting.Light.radius">
<code class="descname">radius</code><a class="headerlink" href="#trimesh.scene.lighting.Light.radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.scene.lighting.PointLight">
<em class="property">class </em><code class="descclassname">trimesh.scene.lighting.</code><code class="descname">PointLight</code><span class="sig-paren">(</span><em>name=None</em>, <em>color=None</em>, <em>intensity=None</em>, <em>radius=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.lighting.PointLight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.scene.lighting.Light" title="trimesh.scene.lighting.Light"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.scene.lighting.Light</span></code></a></p>
<p>Point lights emit light in all directions from their position in space;
rotation and scale are ignored except for their effect on the inherited
node position. The brightness of the light attenuates in a physically
correct manner as distance increases from the light’s position (i.e.
brightness goes like the inverse square of the distance). Point light
intensity is defined in candela, which is lumens per square radian (lm/sr).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the light.</p>
</dd>
<dt><strong>color</strong><span class="classifier">(4,) uint8</span></dt><dd><p>RGBA value for the light’s color in linear space.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">float</span></dt><dd><p>Brightness of light. The units that this is defined in depend on the type of light.
point and spot lights use luminous intensity in candela (lm/sr),
while directional lights use illuminance in lux (lm/m2).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Cutoff distance at which light’s intensity may be considered to
have reached zero. Supported only for point and spot lights, must be &gt; 0.
If None, the radius is assumed to be infinite.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="trimesh.scene.lighting.SpotLight">
<em class="property">class </em><code class="descclassname">trimesh.scene.lighting.</code><code class="descname">SpotLight</code><span class="sig-paren">(</span><em>name=None</em>, <em>color=None</em>, <em>intensity=None</em>, <em>radius=None</em>, <em>innerConeAngle=0.0</em>, <em>outerConeAngle=0.7853981633974483</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.lighting.SpotLight" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.scene.lighting.Light" title="trimesh.scene.lighting.Light"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.scene.lighting.Light</span></code></a></p>
<p>Spot lights emit light in a cone in the direction of the local -z axis.
The angle and falloff of the cone is defined using two numbers, the
<cite>innerConeAngle</cite> and <cite>outerConeAngle</cite>. As with point lights, the brightness
also attenuates in a physically correct manner as distance increases from
the light’s position (i.e. brightness goes like the inverse square of the
distance). Spot light intensity refers to the brightness inside the
<cite>innerConeAngle</cite> (and at the location of the light) and is defined in
candela, which is lumens per square radian (lm/sr). A spot light’s position
and orientation are inherited from its node transform. Inherited scale does
not affect cone shape, and is ignored except for its effect on position
and orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Name of the light.</p>
</dd>
<dt><strong>color</strong><span class="classifier">(4,) uint8</span></dt><dd><p>RGBA value for the light’s color in linear space.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">float</span></dt><dd><p>Brightness of light. The units that this is defined in depend on the type of light.
point and spot lights use luminous intensity in candela (lm/sr),
while directional lights use illuminance in lux (lm/m2).</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Cutoff distance at which light’s intensity may be considered to
have reached zero. Supported only for point and spot lights, must be &gt; 0.
If None, the radius is assumed to be infinite.</p>
</dd>
<dt><strong>innerConeAngle</strong><span class="classifier">float</span></dt><dd><p>Angle, in radians, from centre of spotlight where falloff begins.
Must be greater than or equal to <cite>0</cite> and less than <cite>outerConeAngle</cite>.</p>
</dd>
<dt><strong>outerConeAngle</strong><span class="classifier">float</span></dt><dd><p>Angle, in radians, from centre of spotlight where falloff ends.
Must be greater than <cite>innerConeAngle</cite> and less than or equal to <cite>PI / 2.0</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="trimesh.scene.lighting.SpotLight.innerConeAngle">
<code class="descname">innerConeAngle</code><a class="headerlink" href="#trimesh.scene.lighting.SpotLight.innerConeAngle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.lighting.SpotLight.outerConeAngle">
<code class="descname">outerConeAngle</code><a class="headerlink" href="#trimesh.scene.lighting.SpotLight.outerConeAngle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.scene.lighting.autolight">
<code class="descclassname">trimesh.scene.lighting.</code><code class="descname">autolight</code><span class="sig-paren">(</span><em>scene</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.lighting.autolight" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of lights for a scene that looks decent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scene</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Scene with geometry</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lights</strong><span class="classifier">[Light]</span></dt><dd><p>List of light objects</p>
</dd>
<dt><strong>transforms</strong><span class="classifier">(len(lights), 4, 4) float</span></dt><dd><p>Transformation matrices for light positions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.scene.scene">
<span id="trimesh-scene-scene-module"></span><h2>trimesh.scene.scene module<a class="headerlink" href="#module-trimesh.scene.scene" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.scene.scene.Scene">
<em class="property">class </em><code class="descclassname">trimesh.scene.scene.</code><code class="descname">Scene</code><span class="sig-paren">(</span><em>geometry=None</em>, <em>base_frame='world'</em>, <em>metadata={}</em>, <em>graph=None</em>, <em>camera=None</em>, <em>lights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="trimesh.html#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<p>A simple scene graph which can be rendered directly via
pyglet/openGL or through other endpoints such as a
raytracer. Meshes are added by name, which can then be
moved by updating transform in the transform tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.bounds" title="trimesh.scene.scene.Scene.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt><dd><p>Return the overall bounding box of the scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.bounds_corners" title="trimesh.scene.scene.Scene.bounds_corners"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds_corners</span></code></a></dt><dd><p>A list of points that represent the corners of the AABB of every geometry in the scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.camera" title="trimesh.scene.scene.Scene.camera"><code class="xref py py-obj docutils literal notranslate"><span class="pre">camera</span></code></a></dt><dd><p>Get the single camera for the scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.centroid" title="trimesh.scene.scene.Scene.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></a></dt><dd><p>Return the center of the bounding box for the scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.convex_hull" title="trimesh.scene.scene.Scene.convex_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></a></dt><dd><p>The convex hull of the whole scene</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.duplicate_nodes" title="trimesh.scene.scene.Scene.duplicate_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">duplicate_nodes</span></code></a></dt><dd><p>Return a sequence of node keys of identical meshes.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.extents" title="trimesh.scene.scene.Scene.extents"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></a></dt><dd><p>Return the axis aligned box size of the current scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.geometry_identifiers" title="trimesh.scene.scene.Scene.geometry_identifiers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geometry_identifiers</span></code></a></dt><dd><p>Look up geometries by identifier MD5</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.is_empty" title="trimesh.scene.scene.Scene.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a></dt><dd><p>Does the scene have anything in it.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.is_valid" title="trimesh.scene.scene.Scene.is_valid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_valid</span></code></a></dt><dd><p>Is every geometry connected to the root node.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.lights" title="trimesh.scene.scene.Scene.lights"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lights</span></code></a></dt><dd><p>Get a list of the lights in the scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.scale" title="trimesh.scene.scene.Scene.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a></dt><dd><p>The approximate scale of the mesh</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.triangles" title="trimesh.scene.scene.Scene.triangles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></a></dt><dd><p>Return a correctly transformed polygon soup of the current scene.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.triangles_node" title="trimesh.scene.scene.Scene.triangles_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_node</span></code></a></dt><dd><p>Which node of self.graph does each triangle come from.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.scene.Scene.units" title="trimesh.scene.scene.Scene.units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></a></dt><dd><p>Get the units for every model in the scene, and raise a ValueError if there are mixed units.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.add_geometry" title="trimesh.scene.scene.Scene.add_geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_geometry</span></code></a>(geometry[, node_name, …])</p></td>
<td><p>Add a geometry to the scene.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.convert_units" title="trimesh.scene.scene.Scene.convert_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code></a>(desired[, guess])</p></td>
<td><p>If geometry has units defined convert them to new units.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.copy" title="trimesh.scene.scene.Scene.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return a deep copy of the current scene</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.dump" title="trimesh.scene.scene.Scene.dump"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code></a>()</p></td>
<td><p>Append all meshes in scene to a list of meshes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.explode" title="trimesh.scene.scene.Scene.explode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">explode</span></code></a>([vector, origin])</p></td>
<td><p>Explode a scene around a point and vector.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.export" title="trimesh.scene.scene.Scene.export"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code></a>([file_type])</p></td>
<td><p>Export a snapshot of the current scene.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.md5" title="trimesh.scene.scene.Scene.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>MD5 of scene which will change when meshes or transforms are changed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.rezero" title="trimesh.scene.scene.Scene.rezero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code></a>()</p></td>
<td><p>Move the current scene so that the AABB of the whole scene is centered at the origin.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.save_image" title="trimesh.scene.scene.Scene.save_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_image</span></code></a>([resolution])</p></td>
<td><p>Get a PNG image of a scene.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.scaled" title="trimesh.scene.scene.Scene.scaled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scaled</span></code></a>(scale)</p></td>
<td><p>Return a copy of the current scene, with meshes and scene transforms scaled to the requested factor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.set_camera" title="trimesh.scene.scene.Scene.set_camera"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_camera</span></code></a>([angles, distance, center, …])</p></td>
<td><p>Create a camera object for self.camera, and add a transform to self.graph for it.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.scene.Scene.show" title="trimesh.scene.scene.Scene.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>([viewer])</p></td>
<td><p>Display the current scene.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 66%" />
<col style="width: 34%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>apply_transform</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.scene.scene.Scene.add_geometry">
<code class="descname">add_geometry</code><span class="sig-paren">(</span><em>geometry</em>, <em>node_name=None</em>, <em>geom_name=None</em>, <em>parent_node_name=None</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.add_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a geometry to the scene.</p>
<p>If the mesh has multiple transforms defined in its
metadata, they will all be copied into the
TransformForest of the current scene automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>geometry</strong><span class="classifier">Trimesh, Path2D, Path3D PointCloud or list</span></dt><dd><p>Geometry to initially add to the scene</p>
</dd>
<dt><strong>base_frame</strong><span class="classifier">str or hashable</span></dt><dd><p>Name of base frame</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">dict</span></dt><dd><p>Any metadata about the scene</p>
</dd>
<dt><strong>graph</strong><span class="classifier">TransformForest or None</span></dt><dd><p>A passed transform graph to use</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>node_name</strong><span class="classifier">str</span></dt><dd><p>Name of node in self.graph</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.scene.scene.Scene.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall bounding box of the scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds: (2,3) float points for min, max corner</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.bounds_corners">
<code class="descname">bounds_corners</code><a class="headerlink" href="#trimesh.scene.scene.Scene.bounds_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of points that represent the corners of the
AABB of every geometry in the scene.</p>
<p>This can be useful if you want to take the AABB in
a specific frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>corners: (n, 3) float, points in space</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.camera">
<code class="descname">camera</code><a class="headerlink" href="#trimesh.scene.scene.Scene.camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the single camera for the scene. If not manually
set one will abe automatically generated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>camera</strong><span class="classifier">trimesh.scene.Camera</span></dt><dd><p>Camera object defined for the scene</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#trimesh.scene.scene.Scene.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the center of the bounding box for the scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>centroid: (3) float point for center of bounding box</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.convert_units">
<code class="descname">convert_units</code><span class="sig-paren">(</span><em>desired</em>, <em>guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>If geometry has units defined convert them to new units.</p>
<p>Returns a new scene with geometries and transforms scaled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>desired</strong><span class="classifier">str</span></dt><dd><p>Desired final unit system: ‘inches’, ‘mm’, etc.</p>
</dd>
<dt><strong>guess</strong><span class="classifier">bool</span></dt><dd><p>Is the converter allowed to guess scale when models
don’t have it specified in their metadata.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Copy of scene with scaling applied and units set
for every model</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#trimesh.scene.scene.Scene.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>The convex hull of the whole scene</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hull: Trimesh object, convex hull of all meshes in scene</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the current scene</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>copied</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Copy of the current scene</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all meshes in scene to a list of meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dumped: (n,) list, of Trimesh objects transformed to their</strong></dt><dd><p>location the scene.graph</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.duplicate_nodes">
<code class="descname">duplicate_nodes</code><a class="headerlink" href="#trimesh.scene.scene.Scene.duplicate_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sequence of node keys of identical meshes.</p>
<p>Will combine meshes duplicated by copying in space with different keys in
self.geometry, as well as meshes repeated by self.nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>duplicates: (m) sequence of keys to self.nodes that represent</strong></dt><dd><p>identical geometry</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.explode">
<code class="descname">explode</code><span class="sig-paren">(</span><em>vector=None</em>, <em>origin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.explode" title="Permalink to this definition">¶</a></dt>
<dd><p>Explode a scene around a point and vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vector</strong><span class="classifier">(3,) float or float</span></dt><dd><p>Explode radially around a direction vector or spherically</p>
</dd>
<dt><strong>origin</strong><span class="classifier">(3,) float</span></dt><dd><p>Point to explode around</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.export">
<code class="descname">export</code><span class="sig-paren">(</span><em>file_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a snapshot of the current scene.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_type: what encoding to use for meshes</strong></dt><dd><p>ie: dict, dict64, stl</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>export: dict with keys:</strong></dt><dd><p>meshes: list of meshes, encoded as per file_type
transforms: edge list of transforms, eg:</p>
<blockquote>
<div><p>((u, v, {‘matrix’ : np.eye(4)}))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.scene.scene.Scene.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the axis aligned box size of the current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>extents: (3,) float, bounding box sides length</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.geometry_identifiers">
<code class="descname">geometry_identifiers</code><a class="headerlink" href="#trimesh.scene.scene.Scene.geometry_identifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up geometries by identifier MD5</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>identifiers: dict, identifier md5: key in self.geometry</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.is_empty">
<code class="descname">is_empty</code><a class="headerlink" href="#trimesh.scene.scene.Scene.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the scene have anything in it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_empty: bool, True if nothing is in the scene</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.is_valid">
<code class="descname">is_valid</code><a class="headerlink" href="#trimesh.scene.scene.Scene.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Is every geometry connected to the root node.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_valid</strong><span class="classifier">bool</span></dt><dd><p>Does every geometry have a transform</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.lights">
<code class="descname">lights</code><a class="headerlink" href="#trimesh.scene.scene.Scene.lights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of the lights in the scene. If nothing is
set it will generate some automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lights</strong><span class="classifier">[trimesh.scene.lighting.Light]</span></dt><dd><p>Lights in the scene.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>MD5 of scene which will change when meshes or
transforms are changed</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hashed: str, MD5 hash of scene</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.rezero">
<code class="descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the current scene so that the AABB of the whole
scene is centered at the origin.</p>
<p>Does this by changing the base frame to a new, offset
base frame.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.save_image">
<code class="descname">save_image</code><span class="sig-paren">(</span><em>resolution=(1024</em>, <em>768)</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.save_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a PNG image of a scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>resolution: (2,) int, resolution to render image</strong></dt><dd></dd>
<dt><strong>**kwargs:  passed to SceneViewer constructor</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>png: bytes, render of scene in PNG form</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.scale">
<code class="descname">scale</code><a class="headerlink" href="#trimesh.scene.scene.Scene.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate scale of the mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale: float, the mean of the bounding box edge lengths</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.scaled">
<code class="descname">scaled</code><span class="sig-paren">(</span><em>scale</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the current scene, with meshes and scene
transforms scaled to the requested factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float</span></dt><dd><p>Factor to scale meshes and transforms</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>A copy of the current scene but scaled</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.set_camera">
<code class="descname">set_camera</code><span class="sig-paren">(</span><em>angles=None</em>, <em>distance=None</em>, <em>center=None</em>, <em>resolution=None</em>, <em>fov=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.set_camera" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a camera object for self.camera, and add
a transform to self.graph for it.</p>
<p>If arguments are not passed sane defaults will be figured
out which show the mesh roughly centered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>angles</strong><span class="classifier">(3,) float</span></dt><dd><p>Initial euler angles in radians</p>
</dd>
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>Distance from centroid</p>
</dd>
<dt><strong>center</strong><span class="classifier">(3,) float</span></dt><dd><p>Point camera should be center on</p>
</dd>
<dt><strong>camera</strong><span class="classifier">Camera object</span></dt><dd><p>Object that stores camera parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.scene.Scene.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>viewer=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.Scene.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the current scene.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>viewer: str ‘gl’:       open a pyglet window</strong></dt><dd><p>str,’notebook’: return ipython.display.HTML
None: automatically pick based on whether or not</p>
<blockquote>
<div><p>we are in an ipython notebook</p>
</div></blockquote>
</dd>
<dt><strong>smooth</strong><span class="classifier">bool</span></dt><dd><p>Turn on or off automatic smooth shading</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.triangles">
<code class="descname">triangles</code><a class="headerlink" href="#trimesh.scene.scene.Scene.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a correctly transformed polygon soup of the
current scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles: (n,3,3) float, triangles in space</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.triangles_node">
<code class="descname">triangles_node</code><a class="headerlink" href="#trimesh.scene.scene.Scene.triangles_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Which node of self.graph does each triangle come from.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles_index</strong><span class="classifier">(len(self.triangles),)</span></dt><dd><p>Node name for each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.scene.Scene.units">
<code class="descname">units</code><a class="headerlink" href="#trimesh.scene.scene.Scene.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the units for every model in the scene, and
raise a ValueError if there are mixed units.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>Units for every model in the scene</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.scene.scene.append_scenes">
<code class="descclassname">trimesh.scene.scene.</code><code class="descname">append_scenes</code><span class="sig-paren">(</span><em>iterable, common=['world']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.append_scenes" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate multiple scene objects into one scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iterable</strong><span class="classifier">(n,) Trimesh or Scene</span></dt><dd><p>Geometries that should be appended</p>
</dd>
<dt><strong>common</strong><span class="classifier">(n,) str</span></dt><dd><p>Nodes that shouldn’t be remapped</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Scene containing all geometry</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.scene.scene.split_scene">
<code class="descclassname">trimesh.scene.scene.</code><code class="descname">split_scene</code><span class="sig-paren">(</span><em>geometry</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.scene.split_scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geometry, list of geometries, or a Scene
return them as a single Scene object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>geometry</strong><span class="classifier">splittable</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scene: trimesh.Scene</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.scene.transforms">
<span id="trimesh-scene-transforms-module"></span><h2>trimesh.scene.transforms module<a class="headerlink" href="#module-trimesh.scene.transforms" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.scene.transforms.EnforcedForest">
<em class="property">class </em><code class="descclassname">trimesh.scene.transforms.</code><code class="descname">EnforcedForest</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">networkx.classes.digraph.DiGraph</span></code></p>
<p>A subclass of networkx.DiGraph that will raise an error if an
edge is added which would make the DiGraph not a forest or tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cycle</span></code>(nodes, **attr)</p></td>
<td><p>Add a cycle.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.add_edge" title="trimesh.scene.transforms.EnforcedForest.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a>(u, v, *args, **kwargs)</p></td>
<td><p>Add an edge between u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.add_edges_from" title="trimesh.scene.transforms.EnforcedForest.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a>(*args, **kwargs)</p></td>
<td><p>Add all the edges in ebunch.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code>(n[, attr_dict])</p></td>
<td><p>Add a single node n and update node attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code>(nodes, **attr)</p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.add_path" title="trimesh.scene.transforms.EnforcedForest.add_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_path</span></code></a>(*args, **kwargs)</p></td>
<td><p>Add a path.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_star</span></code>(nodes, **attr)</p></td>
<td><p>Add a star.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code>(ebunch[, weight])</p></td>
<td><p>Add all the edges in ebunch as weighted edges with specified weights.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacency_iter</span></code>()</p></td>
<td><p>Return an iterator of (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacency_list</span></code>()</p></td>
<td><p>Return an adjacency list representation of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjlist_dict_factory</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code>([nbunch, weight])</p></td>
<td><p>Return the degree of a node or nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree_iter</span></code>([nbunch, weight])</p></td>
<td><p>Return an iterator for (node, degree).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_attr_dict_factory</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code>([nbunch, data, default])</p></td>
<td><p>Return a list of edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_iter</span></code>([nbunch, data, default])</p></td>
<td><p>Return an iterator over the edges.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_data</span></code>(u, v[, default])</p></td>
<td><p>Return the attribute dictionary associated with edge (u,v).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge</span></code>(u, v)</p></td>
<td><p>Return True if the edge (u,v) is in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node</span></code>(n)</p></td>
<td><p>Return True if the graph contains the node n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_predecessor</span></code>(u, v)</p></td>
<td><p>Return True if node u has predecessor v.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_successor</span></code>(u, v)</p></td>
<td><p>Return True if node u has successor v.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code>([nbunch, weight])</p></td>
<td><p>Return the in-degree of a node or nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree_iter</span></code>([nbunch, weight])</p></td>
<td><p>Return an iterator for (node, in-degree).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code>([nbunch, data])</p></td>
<td><p>Return a list of the incoming edges.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges_iter</span></code>([nbunch, data])</p></td>
<td><p>Return an iterator over the incoming edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_directed</span></code>()</p></td>
<td><p>Return True if graph is directed, False otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multigraph</span></code>()</p></td>
<td><p>Return True if graph is a multigraph, False otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbunch_iter</span></code>([nbunch])</p></td>
<td><p>Return an iterator of nodes contained in nbunch that are also in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors</span></code>(n)</p></td>
<td><p>Return a list of successor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors_iter</span></code>(n)</p></td>
<td><p>Return an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_dict_factory</span></code></p></td>
<td><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code>([data])</p></td>
<td><p>Return a list of the nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes_iter</span></code>([data])</p></td>
<td><p>Return an iterator over the nodes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes_with_selfloops</span></code>()</p></td>
<td><p>Return a list of nodes with self loops.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code>([u, v])</p></td>
<td><p>Return the number of edges between two nodes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code>()</p></td>
<td><p>Return the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_selfloops</span></code>()</p></td>
<td><p>Return the number of selfloop edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code>()</p></td>
<td><p>Return the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code>([nbunch, weight])</p></td>
<td><p>Return the out-degree of a node or nodes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree_iter</span></code>([nbunch, weight])</p></td>
<td><p>Return an iterator for (node, out-degree).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code>([nbunch, data, default])</p></td>
<td><p>Return a list of edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges_iter</span></code>([nbunch, data, default])</p></td>
<td><p>Return an iterator over the edges.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code>(n)</p></td>
<td><p>Return a list of predecessor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors_iter</span></code>(n)</p></td>
<td><p>Return an iterator over predecessor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.remove_edge" title="trimesh.scene.transforms.EnforcedForest.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a>(*args, **kwargs)</p></td>
<td><p>Remove the edge between u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.remove_edges_from" title="trimesh.scene.transforms.EnforcedForest.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a>(*args, **kwargs)</p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code>(n)</p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code>(nbunch)</p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code>([copy])</p></td>
<td><p>Return the reverse of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">selfloop_edges</span></code>([data, default])</p></td>
<td><p>Return a list of selfloop edges.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code>([weight])</p></td>
<td><p>Return the number of edges.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraph</span></code>(nbunch)</p></td>
<td><p>Return the subgraph induced on nodes in nbunch.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code>(n)</p></td>
<td><p>Return a list of successor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors_iter</span></code>(n)</p></td>
<td><p>Return an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code>()</p></td>
<td><p>Return a directed copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code>([reciprocal])</p></td>
<td><p>Return an undirected representation of the digraph.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>disconnect_path</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_edge_data_direction</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>shortest_path_undirected</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.add_edge">
<code class="descname">add_edge</code><span class="sig-paren">(</span><em>u</em>, <em>v</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge between u and v.</p>
<p>The nodes u and v will be automatically added if they are
not already in the graph.</p>
<p>Edge attributes can be specified with keywords or by providing
a dictionary with key/value pairs.  See examples below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd><p>Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</p>
</dd>
<dt><strong>attr_dict</strong><span class="classifier">dictionary, optional (default= no attributes)</span></dt><dd><p>Dictionary of edge attributes.  Key/value pairs will
update existing data associated with the edge.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional</span></dt><dd><p>Edge data (or labels or objects) can be assigned using
keyword arguments.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.add_edges_from" title="trimesh.scene.transforms.EnforcedForest.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add a collection of edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding an edge that already exists updates the edge data.</p>
<p>Many NetworkX algorithms designed for weighted graphs use as
the edge weight a numerical value assigned to a keyword
which by default is ‘weight’.</p>
<p class="rubric">Examples</p>
<p>The following all add the edge e=(1,2) to graph G:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>           <span class="c1"># explicit two-node form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>             <span class="c1"># single edge as tuple of two nodes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span> <span class="p">)</span> <span class="c1"># add edges from iterable container</span>
</pre></div>
</div>
<p>Associate data to edges using keywords:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">342.7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.add_edges_from">
<code class="descname">add_edges_from</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.add_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all the edges in ebunch.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ebunch</strong><span class="classifier">container of edges</span></dt><dd><p>Each edge given in the container will be added to the
graph. The edges must be given as as 2-tuples (u,v) or
3-tuples (u,v,d) where d is a dictionary containing edge
data.</p>
</dd>
<dt><strong>attr_dict</strong><span class="classifier">dictionary, optional (default= no attributes)</span></dt><dd><p>Dictionary of edge attributes.  Key/value pairs will
update existing data associated with each edge.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional</span></dt><dd><p>Edge data (or labels or objects) can be assigned using
keyword arguments.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.add_edge" title="trimesh.scene.transforms.EnforcedForest.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></dt><dd><p>add a single edge</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></dt><dd><p>convenient way to add weighted edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding the same edge twice has no effect but any edge data
will be updated when each duplicate edge is added.</p>
<p>Edge attributes specified in edges take precedence
over attributes specified generally.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span> <span class="c1"># using a list of edge tuples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1"># Add the path graph 0-1-2-3</span>
</pre></div>
</div>
<p>Associate data to edges</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;WN2898&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.add_path">
<code class="descname">add_path</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.add_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">iterable container</span></dt><dd><p>A container of nodes.  A path will be constructed from
the nodes (in order) and added to the graph.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional (default= no attributes)</span></dt><dd><p>Attributes to add to every edge in path.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_star</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cycle</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">],</span><span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.disconnect_path">
<code class="descname">disconnect_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.disconnect_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.get_edge_data_direction">
<code class="descname">get_edge_data_direction</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.get_edge_data_direction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.remove_edge">
<code class="descname">remove_edge</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.remove_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the edge between u and v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd><p>Remove the edge between nodes u and v.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>NetworkXError</strong></dt><dd><p>If there is not an edge between u and v.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.remove_edges_from" title="trimesh.scene.transforms.EnforcedForest.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a></dt><dd><p>remove a collection of edges</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="c1"># unpacks e from an edge tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">})</span> <span class="c1"># an edge with attribute data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># select first part of edge tuple</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.remove_edges_from">
<code class="descname">remove_edges_from</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.remove_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all edges specified in ebunch.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ebunch: list or container of edge tuples</strong></dt><dd><p>Each edge given in the list or container will be removed
from the graph. The edges can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>2-tuples (u,v) edge between u and v.</p></li>
<li><p>3-tuples (u,v,k) where k is ignored.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.transforms.EnforcedForest.remove_edge" title="trimesh.scene.transforms.EnforcedForest.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a></dt><dd><p>remove a single edge</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Will fail silently if an edge in ebunch is not in the graph.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>   <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_path</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebunch</span><span class="o">=</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.EnforcedForest.shortest_path_undirected">
<code class="descname">shortest_path_undirected</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.EnforcedForest.shortest_path_undirected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.scene.transforms.TransformForest">
<em class="property">class </em><code class="descclassname">trimesh.scene.transforms.</code><code class="descname">TransformForest</code><span class="sig-paren">(</span><em>base_frame='world'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.nodes" title="trimesh.scene.transforms.TransformForest.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a></dt><dd><p>A list of every node in the graph.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.nodes_geometry" title="trimesh.scene.transforms.TransformForest.nodes_geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes_geometry</span></code></a></dt><dd><p>The nodes in the scene graph with geometry attached.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.copy" title="trimesh.scene.transforms.TransformForest.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return a copy of the current TransformForest</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.from_edgelist" title="trimesh.scene.transforms.TransformForest.from_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_edgelist</span></code></a>(edges[, strict])</p></td>
<td><p>Load transform data from an edge list into the current scene graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.get" title="trimesh.scene.transforms.TransformForest.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(frame_to[, frame_from])</p></td>
<td><p>Get the transform from one frame to another, assuming they are connected in the transform tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.load" title="trimesh.scene.transforms.TransformForest.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(edgelist)</p></td>
<td><p>Load transform data from an edge list into the current scene graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.md5" title="trimesh.scene.transforms.TransformForest.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>MD5 of transforms.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.show" title="trimesh.scene.transforms.TransformForest.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>()</p></td>
<td><p>Plot the graph layout of the scene.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.to_edgelist" title="trimesh.scene.transforms.TransformForest.to_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_edgelist</span></code></a>()</p></td>
<td><p>Export the current transforms as a list of edge tuples, with each tuple having the format: (node_a, node_b, {metadata})</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.to_flattened" title="trimesh.scene.transforms.TransformForest.to_flattened"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_flattened</span></code></a>([base_frame])</p></td>
<td><p>Export the current transform graph as a flattened</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.to_gltf" title="trimesh.scene.transforms.TransformForest.to_gltf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gltf</span></code></a>(scene)</p></td>
<td><p>Export a transforms as the ‘nodes’ section of a GLTF dict.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.scene.transforms.TransformForest.update" title="trimesh.scene.transforms.TransformForest.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(frame_to[, frame_from])</p></td>
<td><p>Update a transform in the tree.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>clear</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_svg</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the current TransformForest</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>copied: TransformForest</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.from_edgelist">
<code class="descname">from_edgelist</code><span class="sig-paren">(</span><em>edges</em>, <em>strict=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.from_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Load transform data from an edge list into the current
scene graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edgelist</strong><span class="classifier">(n,) tuples</span></dt><dd><p>(node_a, node_b, {key: value})</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool</span></dt><dd><p>If true, raise a ValueError when a
malformed edge is passed in a tuple.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>frame_to</em>, <em>frame_from=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transform from one frame to another, assuming they are connected
in the transform tree.</p>
<p>If the frames are not connected a NetworkXNoPath error will be raised.</p>
<dl class="simple">
<dt>frame_from: hashable object, usually a string (eg ‘world’).</dt><dd><p>If left as None it will be set to self.base_frame</p>
</dd>
</dl>
<p>frame_to:   hashable object, usually a string (eg ‘mesh_0’)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform:  (4,4) homogenous transformation matrix</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>edgelist</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load transform data from an edge list into the current
scene graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edgelist</strong><span class="classifier">(n,) tuples</span></dt><dd><p>(node_a, node_b, {key: value})</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>MD5 of transforms.</p>
<p>Currently only hashing update time.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.transforms.TransformForest.nodes">
<code class="descname">nodes</code><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of every node in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes: (n,) array, of node names</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.scene.transforms.TransformForest.nodes_geometry">
<code class="descname">nodes_geometry</code><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.nodes_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>The nodes in the scene graph with geometry attached.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_geometry: (m,) array, of node names</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the graph layout of the scene.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.to_edgelist">
<code class="descname">to_edgelist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.to_edgelist" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current transforms as a list of edge tuples, with
each tuple having the format:
(node_a, node_b, {metadata})</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edgelist: (n,) list of tuples</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.to_flattened">
<code class="descname">to_flattened</code><span class="sig-paren">(</span><em>base_frame=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.to_flattened" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current transform graph as a flattened</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.to_gltf">
<code class="descname">to_gltf</code><span class="sig-paren">(</span><em>scene</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.to_gltf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a transforms as the ‘nodes’ section of a GLTF dict.
Flattens tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gltf</strong><span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>with keys:</dt><dd><p>‘nodes’: list of dicts</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.to_svg">
<code class="descname">to_svg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.to_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.scene.transforms.TransformForest.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>frame_to</em>, <em>frame_from=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.TransformForest.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a transform in the tree.</p>
<dl class="simple">
<dt>frame_from: hashable object, usually a string (eg ‘world’).</dt><dd><p>If left as None it will be set to self.base_frame</p>
</dd>
</dl>
<p>frame_to:   hashable object, usually a string (eg ‘mesh_0’)</p>
<p>matrix:      (4,4) array
quaternion:  (4) quaternion
axis:        (3) array
angle:       float, radians
translation: (3) array
geometry : Geometry object name</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.scene.transforms.kwargs_to_matrix">
<code class="descclassname">trimesh.scene.transforms.</code><code class="descname">kwargs_to_matrix</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.kwargs_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a set of keyword arguments into a transformation matrix.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.scene.transforms.path_to_edges">
<code class="descclassname">trimesh.scene.transforms.</code><code class="descname">path_to_edges</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.scene.transforms.path_to_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn an (n) path into a (2(n-1)) set of edges</p>
</dd></dl>

</div>
<div class="section" id="module-trimesh.scene">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-trimesh.scene" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="trimesh.resources.html" class="btn btn-neutral float-left" title="trimesh.resources package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Dawson-Haggerty

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>