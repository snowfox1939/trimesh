

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trimesh package &mdash; trimesh 2.37.24 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="trimesh.exchange package" href="trimesh.exchange.html" />
    <link rel="prev" title="Module Reference" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> trimesh
          

          
          </a>

          
            
            
              <div class="version">
                2.37.24
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Advanced Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Module Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">trimesh package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.exchange.html">trimesh.exchange package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.viewer.html">trimesh.viewer package</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.visual.html">trimesh.visual package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.base">trimesh.base module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#github-com-mikedh-trimesh">github.com/mikedh/trimesh</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.boolean">trimesh.boolean module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.bounds">trimesh.bounds module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.caching">trimesh.caching module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#caching-py">caching.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.collision">trimesh.collision module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.comparison">trimesh.comparison module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comparison-py">comparison.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.constants">trimesh.constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.convex">trimesh.convex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.creation">trimesh.creation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creation-py">creation.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.curvature">trimesh.curvature module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#curvature-py">curvature.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.decomposition">trimesh.decomposition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.geometry">trimesh.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.graph">trimesh.graph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-py">graph.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.grouping">trimesh.grouping module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grouping-py">grouping.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.inertia">trimesh.inertia module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inertia-py">inertia.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.integrate">trimesh.integrate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#integrate-py">integrate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.intersections">trimesh.intersections module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intersections-py">intersections.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.interval">trimesh.interval module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interval-py">interval.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.nsphere">trimesh.nsphere module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nsphere-py">nsphere.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.parent">trimesh.parent module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parent-py">parent.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.permutate">trimesh.permutate module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#permutate-py">permutate.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.points">trimesh.points module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#points-py">points.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.poses">trimesh.poses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#poses-py">poses.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.primitives">trimesh.primitives module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primitives-py">primitives.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.proximity">trimesh.proximity module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proximity-py">proximity.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.registration">trimesh.registration module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#registration-py">registration.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.remesh">trimesh.remesh module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#remesh-py">remesh.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.rendering">trimesh.rendering module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rendering-py">rendering.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.repair">trimesh.repair module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#repair-py">repair.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.sample">trimesh.sample module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sample-py">sample.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.smoothing">trimesh.smoothing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.transformations">trimesh.transformations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requirements">Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notes">Notes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.triangles">trimesh.triangles module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#triangles-py">triangles.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.units">trimesh.units module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#units-py">units.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.util">trimesh.util module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#util-py">util.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.version">trimesh.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh.voxel">trimesh.voxel module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#voxel-py">voxel.py</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-trimesh">Module contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#https-github-com-mikedh-trimesh">https://github.com/mikedh/trimesh</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">trimesh</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">Module Reference</a> &raquo;</li>
        
      <li>trimesh package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/trimesh.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="trimesh-package">
<h1>trimesh package<a class="headerlink" href="#trimesh-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="trimesh.exchange.html">trimesh.exchange package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.assimp">trimesh.exchange.assimp module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.dae">trimesh.exchange.dae module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.export">trimesh.exchange.export module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.gltf">trimesh.exchange.gltf module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.exchange.html#gltf-py">gltf.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.load">trimesh.exchange.load module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.misc">trimesh.exchange.misc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.openctm">trimesh.exchange.openctm module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.ply">trimesh.exchange.ply module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.stl">trimesh.exchange.stl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.threemf">trimesh.exchange.threemf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.urdf">trimesh.exchange.urdf module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.wavefront">trimesh.exchange.wavefront module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange.xml_based">trimesh.exchange.xml_based module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.exchange.html#module-trimesh.exchange">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.interfaces.html">trimesh.interfaces package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.blender">trimesh.interfaces.blender module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.generic">trimesh.interfaces.generic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.scad">trimesh.interfaces.scad module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces.vhacd">trimesh.interfaces.vhacd module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.interfaces.html#module-trimesh.interfaces">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.path.html">trimesh.path package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.exchange.html">trimesh.path.exchange package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.dxf">trimesh.path.exchange.dxf module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.export">trimesh.path.exchange.export module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.load">trimesh.path.exchange.load module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.misc">trimesh.path.exchange.misc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange.svg_io">trimesh.path.exchange.svg_io module</a></li>
<li class="toctree-l4"><a class="reference internal" href="trimesh.path.exchange.html#module-trimesh.path.exchange">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.arc">trimesh.path.arc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.creation">trimesh.path.creation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.curve">trimesh.path.curve module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.entities">trimesh.path.entities module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#entities-py">entities.py</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.intersections">trimesh.path.intersections module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.packing">trimesh.path.packing module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.path">trimesh.path.path module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.polygons">trimesh.path.polygons module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.raster">trimesh.path.raster module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#raster-py">raster.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.repair">trimesh.path.repair module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#repair-py">repair.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.segments">trimesh.path.segments module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.path.html#segments-py">segments.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.simplify">trimesh.path.simplify module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.traversal">trimesh.path.traversal module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path.util">trimesh.path.util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.path.html#module-trimesh.path">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.ray.html">trimesh.ray package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_pyembree">trimesh.ray.ray_pyembree module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_triangle">trimesh.ray.ray_triangle module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray.ray_util">trimesh.ray.ray_util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.ray.html#module-trimesh.ray">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.resources.html">trimesh.resources package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.resources.html#module-trimesh.resources">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.scene.html">trimesh.scene package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.cameras">trimesh.scene.cameras module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.lighting">trimesh.scene.lighting module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.scene.html#lighting-py">lighting.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.scene">trimesh.scene.scene module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene.transforms">trimesh.scene.transforms module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.scene.html#module-trimesh.scene">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.viewer.html">trimesh.viewer package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer.notebook">trimesh.viewer.notebook module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#notebook-py">notebook.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer.windowed">trimesh.viewer.windowed module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#windowed-py">windowed.py</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.viewer.html#module-trimesh.viewer">Module contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.viewer.html#viewer">viewer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="trimesh.visual.html">trimesh.visual package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.color">trimesh.visual.color module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#visual-py">visual.py</a></li>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#rules">Rules</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.objects">trimesh.visual.objects module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#objects-py">objects.py</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.resolvers">trimesh.visual.resolvers module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#resolvers-py">resolvers.py</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual.texture">trimesh.visual.texture module</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="trimesh.visual.html#module-trimesh.visual">Module contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="trimesh.visual.html#visual">visual</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.base">
<span id="trimesh-base-module"></span><h2>trimesh.base module<a class="headerlink" href="#module-trimesh.base" title="Permalink to this headline">¶</a></h2>
<div class="section" id="github-com-mikedh-trimesh">
<h3>github.com/mikedh/trimesh<a class="headerlink" href="#github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Library for importing, exporting and doing simple operations on triangular meshes.</p>
<dl class="class">
<dt id="trimesh.base.Trimesh">
<em class="property">class </em><code class="descclassname">trimesh.base.</code><code class="descname">Trimesh</code><span class="sig-paren">(</span><em>vertices=None</em>, <em>faces=None</em>, <em>face_normals=None</em>, <em>vertex_normals=None</em>, <em>face_colors=None</em>, <em>vertex_colors=None</em>, <em>metadata=None</em>, <em>process=True</em>, <em>validate=False</em>, <em>use_embree=True</em>, <em>initial_cache={}</em>, <em>visual=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.base.Trimesh.area" title="trimesh.base.Trimesh.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt><dd><p>Summed area of all triangles in the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.area_faces" title="trimesh.base.Trimesh.area_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></a></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.body_count" title="trimesh.base.Trimesh.body_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></a></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.bounds" title="trimesh.base.Trimesh.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.center_mass" title="trimesh.base.Trimesh.center_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></a></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.centroid" title="trimesh.base.Trimesh.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></a></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.convex_hull" title="trimesh.base.Trimesh.convex_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></a></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.density" title="trimesh.base.Trimesh.density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></a></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges" title="trimesh.base.Trimesh.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_face" title="trimesh.base.Trimesh.edges_face"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></a></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_sorted" title="trimesh.base.Trimesh.edges_sorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></a></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_sparse" title="trimesh.base.Trimesh.edges_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></a></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_unique" title="trimesh.base.Trimesh.edges_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></a></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_unique_inverse" title="trimesh.base.Trimesh.edges_unique_inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></a></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.edges_unique_length" title="trimesh.base.Trimesh.edges_unique_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></a></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.euler_number" title="trimesh.base.Trimesh.euler_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></a></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.extents" title="trimesh.base.Trimesh.extents"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></a></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency" title="trimesh.base.Trimesh.face_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></a></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_angles" title="trimesh.base.Trimesh.face_adjacency_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></a></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_convex" title="trimesh.base.Trimesh.face_adjacency_convex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></a></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_edges" title="trimesh.base.Trimesh.face_adjacency_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></a></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_projections" title="trimesh.base.Trimesh.face_adjacency_projections"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></a></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_radius" title="trimesh.base.Trimesh.face_adjacency_radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></a></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_span" title="trimesh.base.Trimesh.face_adjacency_span"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></a></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_tree" title="trimesh.base.Trimesh.face_adjacency_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></a></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_adjacency_unshared" title="trimesh.base.Trimesh.face_adjacency_unshared"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></a></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_angles" title="trimesh.base.Trimesh.face_angles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></a></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_angles_sparse" title="trimesh.base.Trimesh.face_angles_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></a></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.face_normals" title="trimesh.base.Trimesh.face_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></a></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces" title="trimesh.base.Trimesh.faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></a></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces_sparse" title="trimesh.base.Trimesh.faces_sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></a></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.faces_unique_edges" title="trimesh.base.Trimesh.faces_unique_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></a></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets" title="trimesh.base.Trimesh.facets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></a></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_area" title="trimesh.base.Trimesh.facets_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></a></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_boundary" title="trimesh.base.Trimesh.facets_boundary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></a></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_normal" title="trimesh.base.Trimesh.facets_normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></a></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_on_hull" title="trimesh.base.Trimesh.facets_on_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></a></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.facets_origin" title="trimesh.base.Trimesh.facets_origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></a></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.identifier" title="trimesh.base.Trimesh.identifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></a></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.identifier_md5" title="trimesh.base.Trimesh.identifier_md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></a></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_convex" title="trimesh.base.Trimesh.is_convex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></a></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_empty" title="trimesh.base.Trimesh.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_volume" title="trimesh.base.Trimesh.is_volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></a></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_watertight" title="trimesh.base.Trimesh.is_watertight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></a></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.is_winding_consistent" title="trimesh.base.Trimesh.is_winding_consistent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></a></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.kdtree" title="trimesh.base.Trimesh.kdtree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></a></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.mass" title="trimesh.base.Trimesh.mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></a></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.mass_properties" title="trimesh.base.Trimesh.mass_properties"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></a></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.moment_inertia" title="trimesh.base.Trimesh.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt><dd><p>Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_components" title="trimesh.base.Trimesh.principal_inertia_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></a></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_transform" title="trimesh.base.Trimesh.principal_inertia_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></a></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.principal_inertia_vectors" title="trimesh.base.Trimesh.principal_inertia_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></a></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.referenced_vertices" title="trimesh.base.Trimesh.referenced_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></a></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.scale" title="trimesh.base.Trimesh.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry" title="trimesh.base.Trimesh.symmetry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></a></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry_axis" title="trimesh.base.Trimesh.symmetry_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></a></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.symmetry_section" title="trimesh.base.Trimesh.symmetry_section"><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></a></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles" title="trimesh.base.Trimesh.triangles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></a></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_center" title="trimesh.base.Trimesh.triangles_center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></a></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_cross" title="trimesh.base.Trimesh.triangles_cross"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></a></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.triangles_tree" title="trimesh.base.Trimesh.triangles_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></a></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.units" title="trimesh.base.Trimesh.units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></a></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_adjacency_graph" title="trimesh.base.Trimesh.vertex_adjacency_graph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></a></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_defects" title="trimesh.base.Trimesh.vertex_defects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></a></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_neighbors" title="trimesh.base.Trimesh.vertex_neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></a></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertex_normals" title="trimesh.base.Trimesh.vertex_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></a></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.vertices" title="trimesh.base.Trimesh.vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></a></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.visual" title="trimesh.base.Trimesh.visual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></a></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.base.Trimesh.volume" title="trimesh.base.Trimesh.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>Volume of the current mesh calculated using a surface integral.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.apply_obb" title="trimesh.base.Trimesh.apply_obb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code></a>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.apply_transform" title="trimesh.base.Trimesh.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(matrix)</p></td>
<td><p>Transform mesh by a homogenous transformation matrix.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.compute_stable_poses" title="trimesh.base.Trimesh.compute_stable_poses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code></a>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.contains" title="trimesh.base.Trimesh.contains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code></a>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.convert_units" title="trimesh.base.Trimesh.convert_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code></a>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.convex_decomposition" title="trimesh.base.Trimesh.convex_decomposition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code></a>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.copy" title="trimesh.base.Trimesh.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Safely get a copy of the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.crc" title="trimesh.base.Trimesh.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.difference" title="trimesh.base.Trimesh.difference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code></a>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.eval_cached" title="trimesh.base.Trimesh.eval_cached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code></a>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.export" title="trimesh.base.Trimesh.export"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code></a>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.fill_holes" title="trimesh.base.Trimesh.fill_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code></a>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.fix_normals" title="trimesh.base.Trimesh.fix_normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code></a>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.intersection" title="trimesh.base.Trimesh.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code></a>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.invert" title="trimesh.base.Trimesh.invert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code></a>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.md5" title="trimesh.base.Trimesh.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.merge_vertices" title="trimesh.base.Trimesh.merge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code></a>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.outline" title="trimesh.base.Trimesh.outline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code></a>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.process" title="trimesh.base.Trimesh.process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code></a>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.register" title="trimesh.base.Trimesh.register"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code></a>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.remove_degenerate_faces" title="trimesh.base.Trimesh.remove_degenerate_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code></a>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.remove_duplicate_faces" title="trimesh.base.Trimesh.remove_duplicate_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code></a>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.remove_infinite_values" title="trimesh.base.Trimesh.remove_infinite_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code></a>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.remove_unreferenced_vertices" title="trimesh.base.Trimesh.remove_unreferenced_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code></a>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.rezero" title="trimesh.base.Trimesh.rezero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code></a>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.sample" title="trimesh.base.Trimesh.sample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code></a>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.scene" title="trimesh.base.Trimesh.scene"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code></a>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.section" title="trimesh.base.Trimesh.section"><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code></a>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.section_multiplane" title="trimesh.base.Trimesh.section_multiplane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code></a>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.show" title="trimesh.base.Trimesh.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.slice_plane" title="trimesh.base.Trimesh.slice_plane"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code></a>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.smoothed" title="trimesh.base.Trimesh.smoothed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code></a>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.split" title="trimesh.base.Trimesh.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.subdivide" title="trimesh.base.Trimesh.subdivide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code></a>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.submesh" title="trimesh.base.Trimesh.submesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code></a>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.to_dict" title="trimesh.base.Trimesh.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.union" title="trimesh.base.Trimesh.union"><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code></a>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.unmerge_vertices" title="trimesh.base.Trimesh.unmerge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code></a>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.update_faces" title="trimesh.base.Trimesh.update_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code></a>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.update_vertices" title="trimesh.base.Trimesh.update_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code></a>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.base.Trimesh.voxelized" title="trimesh.base.Trimesh.voxelized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code></a>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.base.Trimesh.apply_obb">
<code class="descname">apply_obb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_obb" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the oriented bounding box transform to the current mesh.</p>
<p>This will result in a mesh with an AABB centered at the
origin and the same dimensions as the OBB.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transformation matrix that was applied
to mesh to move it into OBB frame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform mesh by a homogenous transformation matrix.</p>
<p>Does the bookkeeping to avoid recomputing things so this function
should be used rather than directly modifying self.vertices
if possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Homogenous transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.base.Trimesh.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Summed area of all triangles in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Surface area of mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.area_faces">
<code class="descname">area_faces</code><a class="headerlink" href="#trimesh.base.Trimesh.area_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The area of each face in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area_faces</strong><span class="classifier">(n,) float</span></dt><dd><p>Area of each face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.body_count">
<code class="descname">body_count</code><a class="headerlink" href="#trimesh.base.Trimesh.body_count" title="Permalink to this definition">¶</a></dt>
<dd><p>How many connected groups of vertices exist in this mesh.</p>
<p>Note that this number may differ from result in mesh.split,
which is calculated from FACE rather than vertex adjacency.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int</span></dt><dd><p>Number of connected vertex groups</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.base.Trimesh.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the faces of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">(2, 3) float</span></dt><dd><p>Bounding box with [min, max] coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.center_mass">
<code class="descname">center_mass</code><a class="headerlink" href="#trimesh.base.Trimesh.center_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the center of mass/volume.</p>
<p>If the current mesh is not watertight, this is meaningless garbage
unless it was explicitly set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>center_mass</strong><span class="classifier">(3,) float</span></dt><dd><p>Volumetric center of mass of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#trimesh.base.Trimesh.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The point in space which is the average of the triangle centroids
weighted by the area of each triangle.</p>
<p>This will be valid even for non- watertight meshes,
unlike self.center_mass</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>centroid</strong><span class="classifier">(3,) float</span></dt><dd><p>The average vertex weighted by face area</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.compute_stable_poses">
<code class="descname">compute_stable_poses</code><span class="sig-paren">(</span><em>center_mass=None</em>, <em>sigma=0.0</em>, <em>n_samples=1</em>, <em>threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian (mean at com, cov equal to identity times sigma) over n_samples.
For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaulates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogenous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.
The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>center_mass</strong><span class="classifier">(3,) float</span></dt><dd><p>The object center of mass (if None, this method
assumes uniform density and watertightness and
computes a center of mass explicitly)</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>The covariance for the multivariate gaussian used
to sample center of mass locations</p>
</dd>
<dt><strong>n_samples</strong><span class="classifier">int</span></dt><dd><p>The number of samples of the center of mass location</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The probability value at which to threshold
returned stable poses</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transforms</strong><span class="classifier">(n, 4, 4) float</span></dt><dd><p>The homogenous matrices that transform the
object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p>
</dd>
<dt><strong>probs</strong><span class="classifier">(n,) float</span></dt><dd><p>A probability ranging from 0.0 to 1.0 for each pose</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, determine whether or not they are inside the mesh.
This raises an error if called on a non- watertight mesh.</p>
<dl class="simple">
<dt>points<span class="classifier">(n, 3) float</span></dt><dd><p>Points in cartesian space</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>contains</strong><span class="classifier">(n, ) bool</span></dt><dd><p>Whether or not each point is inside the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convert_units">
<code class="descname">convert_units</code><span class="sig-paren">(</span><em>desired</em>, <em>guess=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convert_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the units of the mesh into a specified unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>desired</strong><span class="classifier">string</span></dt><dd><p>Units to convert to (eg ‘inches’)</p>
</dd>
<dt><strong>guess</strong><span class="classifier">boolean</span></dt><dd><p>If self.units are not defined should we
guess the current units of the document and then convert?</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.convex_decomposition">
<code class="descname">convex_decomposition</code><span class="sig-paren">(</span><em>engine=None</em>, <em>maxhulls=20</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<p>testVHACD Parameters which can be passed as kwargs:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>maxhulls</strong><span class="classifier">int</span></dt><dd><p>Maximum number of convex hulls to return</p>
</dd>
<dt><strong>engine</strong><span class="classifier">string</span></dt><dd><p>Which backend to use. Valid choice is ‘vhacd’.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">testVHACD keyword arguments</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>meshes</strong><span class="classifier">list of trimesh.Trimesh</span></dt><dd><p>List of convex meshes that approximate the original</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of
the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>convex</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh of convex hull of current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current mesh.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>copied</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Copy of current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.adler32 checksum for the current mesh data.</p>
<p>This is about 5x faster than an MD5, and the checksum is
checked every time something is requested from the cache so
it gets called a lot.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>crc</strong><span class="classifier">int</span></dt><dd><p>Checksum of current mesh data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.density">
<code class="descname">density</code><a class="headerlink" href="#trimesh.base.Trimesh.density" title="Permalink to this definition">¶</a></dt>
<dd><p>The density of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>The density of the mesh.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean difference between this mesh and n other meshes</p>
<dl class="simple">
<dt>other<span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt><dd><p>Meshes to difference</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>difference</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Difference between self and other Trimesh objects</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges">
<code class="descname">edges</code><a class="headerlink" href="#trimesh.base.Trimesh.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges of the mesh (derived from faces).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n, 2) int</span></dt><dd><p>List of vertex indices making up edges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_face">
<code class="descname">edges_face</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_face" title="Permalink to this definition">¶</a></dt>
<dd><p>Which face does each edge belong to.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges_face</strong><span class="classifier">(n,) int</span></dt><dd><p>Index of self.faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_sorted">
<code class="descname">edges_sorted</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges sorted along axis 1</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges_sorted</strong><span class="classifier">(n, 2)</span></dt><dd><p>Same as self.edges but sorted along axis 1</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_sparse">
<code class="descname">edges_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Edges in sparse bool COO graph format where connected
vertices are True.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse: (len(self.vertices), len(self.vertices)) bool</strong></dt><dd><p>Sparse graph in COO format</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_unique">
<code class="descname">edges_unique</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>The unique edges of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges_unique</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Vertex indices for unique edges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_unique_inverse">
<code class="descname">edges_unique_inverse</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse required to reproduce
self.edges_sorted from self.edges_unique.</p>
<p>Useful for referencing edge properties:
mesh.edges_unique[mesh.edges_unique_inverse] == m.edges_sorted</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inverse</strong><span class="classifier">(len(self.edges),) int</span></dt><dd><p>Indexes of self.edges_unique</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.edges_unique_length">
<code class="descname">edges_unique_length</code><a class="headerlink" href="#trimesh.base.Trimesh.edges_unique_length" title="Permalink to this definition">¶</a></dt>
<dd><p>How long is each unique edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">(len(self.edges_unique), ) float</span></dt><dd><p>Length of each unique edge</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.euler_number">
<code class="descname">euler_number</code><a class="headerlink" href="#trimesh.base.Trimesh.euler_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler characteristic (a topological invariant) for the mesh
In order to guarantee correctness, this should be called after
remove_unreferenced_vertices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Topological invariant</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.eval_cached">
<code class="descname">eval_cached</code><span class="sig-paren">(</span><em>statement</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.eval_cached" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a statement and cache the result before returning.</p>
<p>Statements are evaluated inside the Trimesh object, and</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>statement</strong><span class="classifier">str</span></dt><dd><p>Statement of valid python code</p>
</dd>
<dt><strong>*args</strong><span class="classifier">list</span></dt><dd><p>Available inside statement as args[0], etc</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">result of running eval on statement with args</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>r = mesh.eval_cached(‘np.dot(self.vertices, args[0])’, [0,0,1])</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.export">
<code class="descname">export</code><span class="sig-paren">(</span><em>file_obj=None</em>, <em>file_type=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.export" title="Permalink to this definition">¶</a></dt>
<dd><p>Export the current mesh to a file object.
If file_obj is a filename, file will be written there.</p>
<p>Supported formats are stl, off, ply, collada, json, dict, glb,
dict64, msgpack.</p>
<dl class="simple">
<dt>file_obj: open writeable file object</dt><dd><p>str, file name where to save the mesh
None, if you would like this function to return the export blob</p>
</dd>
<dt>file_type: str</dt><dd><p>Which file type to export as.
If file name is passed this is not required</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.base.Trimesh.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The length, width, and height of the bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>extents</strong><span class="classifier">(3,) float</span></dt><dd><p>Array containing axis aligned [length, width, height]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency">
<code class="descname">face_adjacency</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>adjacency</strong><span class="classifier">(n,2) int</span></dt><dd><p>Pairs of faces which share an edge</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: mesh = trimesh.load(‘models/featuretype.STL’)</p>
<p>In [2]: mesh.face_adjacency
Out[2]:
array([[   0,    1],</p>
<blockquote>
<div><p>[   2,    3],
[   0,    3],
…,
[1112,  949],
[3467, 3475],
[1113, 3475]])</p>
</div></blockquote>
<p>In [3]: mesh.faces[mesh.face_adjacency[0]]
Out[3]:
TrackedArray([[   1,    0,  408],</p>
<blockquote>
<div><p>[1239,    0,    1]], dtype=int64)</p>
</div></blockquote>
<p>In [4]: import networkx as nx</p>
<p>In [5]: graph = nx.from_edgelist(mesh.face_adjacency)</p>
<p>In [6]: groups = nx.connected_components(graph)</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_angles">
<code class="descname">face_adjacency_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle between adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>adjacency_angle</strong><span class="classifier">(n,) float</span></dt><dd><p>Angle between adjacent faces
Each value corresponds with self.face_adjacency</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_convex">
<code class="descname">face_adjacency_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces which are adjacent and locally convex.</p>
<p>What this means is that given faces A and B, the one vertex
in B that is not shared with A, projected onto the plane of A
has a projection that is zero or negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>are_convex</strong><span class="classifier">(len(self.face_adjacency),) bool</span></dt><dd><p>Face pairs that are locally convex</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_edges">
<code class="descname">face_adjacency_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edges that are shared by the adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Vertex indices which correspond to face_adjacency</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_projections">
<code class="descname">face_adjacency_projections</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection of the non- shared vertex of a triangle onto
its adjacent face</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>projections</strong><span class="classifier">(len(self.face_adjacency),) float</span></dt><dd><p>Dot product of vertex
onto plane of adjacent triangle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_radius">
<code class="descname">face_adjacency_radius</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radii</strong><span class="classifier">(len(self.face_adjacency),) float</span></dt><dd><p>Approximate radius formed by triangle pair</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_span">
<code class="descname">face_adjacency_span</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_span" title="Permalink to this definition">¶</a></dt>
<dd><p>The approximate perpendicular projection of the non- shared
vertices in a pair of adjacent faces onto the shared edge of
the two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>span</strong><span class="classifier">(len(self.face_adjacency),) float</span></dt><dd><p>Approximate span between the non- shared vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_tree">
<code class="descname">face_adjacency_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree of face adjacencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree: rtree.index</strong></dt><dd><p>Where each edge in self.face_adjacency has a
rectangular cell</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_adjacency_unshared">
<code class="descname">face_adjacency_unshared</code><a class="headerlink" href="#trimesh.base.Trimesh.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vid_unshared</strong><span class="classifier">(len(mesh.face_adjacency), 2) int</span></dt><dd><p>Indexes of mesh.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_angles">
<code class="descname">face_angles</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle at each vertex of a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>angles</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Angle at each vertex of a face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_angles_sparse">
<code class="descname">face_angles_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse: scipy.sparse.coo_matrix with:</strong></dt><dd><p>dtype: float
shape: (len(self.vertices), len(self.faces))</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.face_normals">
<code class="descname">face_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.face_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unit normal vector for each face.</p>
<p>If a face is degenerate and a normal can’t be generated
a zero magnitude unit vector will be returned for that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normals</strong><span class="classifier">(len(self.faces), 3) np.float64</span></dt><dd><p>Normal vectors of each face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces">
<code class="descname">faces</code><a class="headerlink" href="#trimesh.base.Trimesh.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>The faces of the mesh.</p>
<p>This is regarded as core information which cannot be regenerated from
cache, and as such is stored in self._data which tracks the array for
changes and clears cached values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(n,3) int</span></dt><dd><p>Representing triangles which reference self.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces_sparse">
<code class="descname">faces_sparse</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">scipy.sparse.coo_matrix</span></dt><dd><p>Has properties:
dtype : bool
shape : (len(self.vertices), len(self.faces))</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.faces_unique_edges">
<code class="descname">faces_unique_edges</code><a class="headerlink" href="#trimesh.base.Trimesh.faces_unique_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>For each face return which indexes in mesh.unique_edges constructs
that face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces_unique_edges</strong><span class="classifier">(len(self.faces), 3) int</span></dt><dd><p>Indexes of self.edges_unique that
construct self.faces</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [0]: mesh.faces[0:2]
Out[0]:
TrackedArray([[    1,  6946, 24224],</p>
<blockquote>
<div><p>[ 6946,  1727, 24225]])</p>
</div></blockquote>
<p>In [1]: mesh.edges_unique[mesh.faces_unique_edges[0:2]]
Out[1]:
array([[[    1,  6946],</p>
<blockquote>
<div><blockquote>
<div><p>[ 6946, 24224],
[    1, 24224]],</p>
</div></blockquote>
<dl class="simple">
<dt>[[ 1727,  6946],</dt><dd><p>[ 1727, 24225],
[ 6946, 24225]]])</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets">
<code class="descname">facets</code><a class="headerlink" href="#trimesh.base.Trimesh.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of face indices for coplanar adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>facets</strong><span class="classifier">(n, ) sequence of (m,) int</span></dt><dd><p>Groups of indexes of self.faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_area">
<code class="descname">facets_area</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the area of each facet.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area</strong><span class="classifier">(len(self.facets),) float</span></dt><dd><p>Total area of each facet (group of faces)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_boundary">
<code class="descname">facets_boundary</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the edges which represent the boundary of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges_boundary</strong><span class="classifier">sequence of (n, 2) int</span></dt><dd><p>Indices of self.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_normal">
<code class="descname">facets_normal</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normal of each facet</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normals: (len(self.facets), 3) float</strong></dt><dd><p>A unit normal vector for each facet</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_on_hull">
<code class="descname">facets_on_hull</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_on_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Find which facets of the mesh are on the convex hull.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>on_hull</strong><span class="classifier">(len(mesh.facets),) bool</span></dt><dd><p>is A facet on the meshes convex hull or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.facets_origin">
<code class="descname">facets_origin</code><a class="headerlink" href="#trimesh.base.Trimesh.facets_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a point on the facet plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>origins</strong><span class="classifier">(len(self.facets), 3) float</span></dt><dd><p>A point on each facet plane</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fill_holes">
<code class="descname">fill_holes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single triangle and single quad holes in the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>watertight</strong><span class="classifier">bool</span></dt><dd><p>Is the mesh watertight after the function completes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.fix_normals">
<code class="descname">fix_normals</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and fix problems with self.face_normals and self.faces
winding direction.</p>
<p>For face normals ensure that vectors are consistently pointed
outwards, and that self.faces is wound in the correct direction
for all connected components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>multibody</strong><span class="classifier">None or bool</span></dt><dd><p>Fix normals across multiple bodies
if None automatically pick from body_count</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.identifier">
<code class="descname">identifier</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a float vector which is unique to the mesh
and is robust to rotation and translation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>identifier</strong><span class="classifier">(6,) float</span></dt><dd><p>Identifying properties of the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.identifier_md5">
<code class="descname">identifier_md5</code><a class="headerlink" href="#trimesh.base.Trimesh.identifier_md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the rotation invariant identifier vector</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hashed</strong><span class="classifier">str</span></dt><dd><p>MD5 hash of the identifier vector</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean intersection between this mesh and n other meshes</p>
<dl class="simple">
<dt>other<span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt><dd><p>Meshes to calculate intersections with</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intersection</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh of the volume contained by all passed meshes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.invert">
<code class="descname">invert</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the mesh in- place by reversing the winding of every
face and negating normals without dumping the cache.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_convex">
<code class="descname">is_convex</code><a class="headerlink" href="#trimesh.base.Trimesh.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_convex: bool</strong></dt><dd><p>Is mesh convex or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_empty">
<code class="descname">is_empty</code><a class="headerlink" href="#trimesh.base.Trimesh.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the current mesh have data defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>empty</strong><span class="classifier">bool</span></dt><dd><p>If True, no data is set on the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_volume">
<code class="descname">is_volume</code><a class="headerlink" href="#trimesh.base.Trimesh.is_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh has all the properties required to represent
a valid volume, rather than just a surface.</p>
<p>These properties include being watertight, having consistent
winding and outward facing normals.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>valid</strong><span class="classifier">bool</span></dt><dd><p>Does the mesh represent a volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_watertight">
<code class="descname">is_watertight</code><a class="headerlink" href="#trimesh.base.Trimesh.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is watertight by making sure every edge is
included in two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_watertight</strong><span class="classifier">bool</span></dt><dd><p>Is mesh watertight or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.is_winding_consistent">
<code class="descname">is_winding_consistent</code><a class="headerlink" href="#trimesh.base.Trimesh.is_winding_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the mesh have consistent winding or not.
A mesh with consistent winding has each shared edge
going in an opposite direction from the other in the pair.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>consistent</strong><span class="classifier">bool</span></dt><dd><p>Is winding is consistent or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.kdtree">
<code class="descname">kdtree</code><a class="headerlink" href="#trimesh.base.Trimesh.kdtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.
Not cached as this lead to observed memory issues and segfaults.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">scipy.spatial.cKDTree</span></dt><dd><p>Contains mesh.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.mass">
<code class="descname">mass</code><a class="headerlink" href="#trimesh.base.Trimesh.mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Mass of the current mesh, based on specified density and
volume. If the current mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mass</strong><span class="classifier">float</span></dt><dd><p>Mass of the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.mass_properties">
<code class="descname">mass_properties</code><a class="headerlink" href="#trimesh.base.Trimesh.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass properties of the current mesh.</p>
<p>Assumes uniform density, and result is probably garbage if mesh
isn’t watertight.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>properties</strong><span class="classifier">dict</span></dt><dd><p>With keys:
‘volume’      : in global units^3
‘mass’        : From specified density
‘density’     : Included again for convenience (same as kwarg density)
‘inertia’     : Taken at the center of mass and aligned with global</p>
<blockquote>
<div><p>coordinate system</p>
</div></blockquote>
<p>‘center_mass’ : Center of mass location, in global coordinate system</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>An MD5 of the core geometry information for the mesh,
faces and vertices.</p>
<p>Generated from TrackedArray, which subclasses np.ndarray to monitor for
changes and returns a correct, but lazily evaluated md5 so it only has to
recalculate the hash occasionally, rather than on every call.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md5</strong><span class="classifier">string</span></dt><dd><p>MD5 of everything in the DataStore</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.merge_vertices">
<code class="descname">merge_vertices</code><span class="sig-paren">(</span><em>digits=None</em>, <em>textured=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has vertices that are closer than
trimesh.constants.tol.merge reindex faces to reference
the same index for both vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>If specified overrides tol.merge</p>
</dd>
<dt><strong>textured</strong><span class="classifier">bool</span></dt><dd><p>If True avoids merging vertices with different UV
coordinates. No effect on untextured meshes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.base.Trimesh.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the moment of inertia matrix of the current mesh.
If mesh isn’t watertight this is garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inertia</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Moment of inertia of the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.outline">
<code class="descname">outline</code><span class="sig-paren">(</span><em>face_ids=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of face indexes find the outline of those
faces and return it as a Path3D.</p>
<p>The outline is defined here as every edge which is only
included by a single triangle.</p>
<p>Note that this implies a non-watertight mesh as the
outline of a watertight mesh is an empty path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>face_ids</strong><span class="classifier">(n,) int</span></dt><dd><p>Indices to compute the outline of.
If None, outline of full mesh will be computed.</p>
</dd>
<dt><strong>**kwargs: passed to Path3D constructor</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>path</strong><span class="classifier">Path3D</span></dt><dd><p>Curve in 3D of the outline</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_components">
<code class="descname">principal_inertia_components</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal components of inertia</p>
<p>Ordering corresponds to mesh.principal_inertia_vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>components</strong><span class="classifier">(3,) float</span></dt><dd><p>Principal components of inertia</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_transform">
<code class="descname">principal_inertia_transform</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>A transform which moves the current mesh so the principal
inertia vectors are on the X,Y, and Z axis, and the centroid is
at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Homogenous transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.principal_inertia_vectors">
<code class="descname">principal_inertia_vectors</code><a class="headerlink" href="#trimesh.base.Trimesh.principal_inertia_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the principal axis of inertia.</p>
<p>Ordering corresponds to mesh.principal_inertia_components</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Three vectors pointing along the
principal axis of inertia directions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.process">
<code class="descname">process</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the bare minimum processing to make a mesh useful.</p>
<dl class="simple">
<dt>Does this by:</dt><dd><ol class="arabic simple">
<li><p>removing NaN and Inf values</p></li>
<li><p>merging duplicate vertices</p></li>
</ol>
</dd>
<dt>If self._validate:</dt><dd><ol class="arabic simple" start="3">
<li><p>Remove triangles which have one edge of their rectangular 2D
oriented bounding box shorter than tol.merge</p></li>
<li><p>remove duplicated triangles</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>self: trimesh.Trimesh</strong></dt><dd><p>Current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.referenced_vertices">
<code class="descname">referenced_vertices</code><a class="headerlink" href="#trimesh.base.Trimesh.referenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Which vertices in the current mesh are referenced by a face.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>referenced</strong><span class="classifier">(len(self.vertices),) bool</span></dt><dd><p>Which vertices are referenced by a face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.register">
<code class="descname">register</code><span class="sig-paren">(</span><em>other</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.register" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh object</span></dt><dd><p>Mesh to align with other</p>
</dd>
<dt><strong>other</strong><span class="classifier">trimesh.Trimesh or (n, 3) float</span></dt><dd><p>Mesh or points in space</p>
</dd>
<dt><strong>samples</strong><span class="classifier">int</span></dt><dd><p>Number of samples from mesh surface to align</p>
</dd>
<dt><strong>icp_first</strong><span class="classifier">int</span></dt><dd><p>How many ICP iterations for the 9 possible
combinations of</p>
</dd>
<dt><strong>icp_final</strong><span class="classifier">int</span></dt><dd><p>How many ICP itertations for the closest
candidate from the wider search</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_to_other</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transform to align mesh to the other object</p>
</dd>
<dt><strong>cost</strong><span class="classifier">float</span></dt><dd><p>Average square distance per point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_degenerate_faces">
<code class="descname">remove_degenerate_faces</code><span class="sig-paren">(</span><em>height=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_degenerate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove degenerate faces (faces without 3 unique vertex indices)
from the current mesh.</p>
<p>If a height is specified, it will remove any face with a 2D oriented
bounding box with one edge shorter than that height.</p>
<p>If not specified, it will remove any face with a zero normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>If specified removes faces with an oriented bounding
box shorter than this on one side.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nondegenerate</strong><span class="classifier">(len(self.faces),) bool</span></dt><dd><p>Mask used to remove faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_duplicate_faces">
<code class="descname">remove_duplicate_faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_duplicate_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>On the current mesh remove any faces which are duplicates.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_infinite_values">
<code class="descname">remove_infinite_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_infinite_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that every vertex and face consists of finite numbers.</p>
<p>This will remove vertices or faces containing np.nan and np.inf</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.remove_unreferenced_vertices">
<code class="descname">remove_unreferenced_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.remove_unreferenced_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all vertices in the current mesh which are not
referenced by a face.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.rezero">
<code class="descname">rezero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.rezero" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the mesh so that all vertex vertices are positive.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.sample">
<code class="descname">sample</code><span class="sig-paren">(</span><em>count</em>, <em>return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples distributed normally across the
surface of the mesh</p>
<dl class="simple">
<dt>count<span class="classifier">int</span></dt><dd><p>Number of points to sample</p>
</dd>
<dt>return_index<span class="classifier">bool</span></dt><dd><p>If True will also return the index of which face each
sample was taken from.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples</strong><span class="classifier">(count, 3) float</span></dt><dd><p>Points on surface of mesh</p>
</dd>
<dt><strong>face_index</strong><span class="classifier">(count, ) int</span></dt><dd><p>Index of self.faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.scale">
<code class="descname">scale</code><a class="headerlink" href="#trimesh.base.Trimesh.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>A metric for the overall scale of the mesh, the length of the
diagonal of the axis aligned bounding box of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scale</strong><span class="classifier">float</span></dt><dd><p>The length of the meshes AABB diagonal</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.scene">
<code class="descname">scene</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Scene object containing the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scene</strong><span class="classifier">trimesh.scene.scene.Scene</span></dt><dd><p>Contains just the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>plane_normal</em>, <em>plane_origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3D cross section of the current mesh and a plane
defined by origin and normal.</p>
<dl class="simple">
<dt>plane_normal: (3) vector for plane normal</dt><dd><p>Normal vector of section plane</p>
</dd>
<dt>plane_origin<span class="classifier">(3,) float</span></dt><dd><p>Point on the cross section plane</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intersections: Path3D or None</strong></dt><dd><p>Curve of intersection</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.section_multiplane">
<code class="descname">section_multiplane</code><span class="sig-paren">(</span><em>plane_origin</em>, <em>plane_normal</em>, <em>heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.section_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return multiple parallel cross sections of the current
mesh in 2D.</p>
<dl class="simple">
<dt>plane_normal: (3) vector for plane normal</dt><dd><p>Normal vector of section plane</p>
</dd>
<dt>plane_origin<span class="classifier">(3,) float</span></dt><dd><p>Point on the cross section plane</p>
</dd>
<dt>heights<span class="classifier">(n,) float</span></dt><dd><p>Each section is offset by height along
the plane normal.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>paths</strong><span class="classifier">(n,) Path2D or None</span></dt><dd><p>2D cross sections at specified heights.
path.metadata[‘to_3D’] contains transform
to return 2D section back into 3D space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the mesh in an opengl window. Requires pyglet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>smooth</strong><span class="classifier">bool</span></dt><dd><p>Run smooth shading on mesh or not,
large meshes will be slow</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scene</strong><span class="classifier">trimesh.scene.Scene</span></dt><dd><p>Scene with current mesh in it</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.slice_plane">
<code class="descname">slice_plane</code><span class="sig-paren">(</span><em>plane_origin</em>, <em>plane_normal</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.slice_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns another mesh that is the current mesh
sliced by the plane defined by origin and normal.</p>
<dl class="simple">
<dt>plane_normal: (3) vector for plane normal</dt><dd><p>Normal vector of slicing plane</p>
</dd>
<dt>plane_origin<span class="classifier">(3,) float</span></dt><dd><p>Point on the slicing plane</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_mesh: trimesh.Trimesh or None</strong></dt><dd><p>Subset of current mesh sliced by plane</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.smoothed">
<code class="descname">smoothed</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version of the current mesh which will render
nicely, without changing source mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Angle in radians, face pairs with angles smaller than
this value will appear smoothed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>smoothed</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Non watertight version of current mesh
which will render nicely with smooth shading</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of Trimesh objects, based on face connectivity.
Splits into individual components, sometimes referred to as ‘bodies’</p>
<dl class="simple">
<dt>only_watertight<span class="classifier">bool</span></dt><dd><p>Only return watertight meshes and discard remainder</p>
</dd>
<dt>adjacency<span class="classifier">None or (n, 2) int</span></dt><dd><p>Override face adjacency with custom values</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshes</strong><span class="classifier">(n,) trimesh.Trimesh</span></dt><dd><p>Separate bodies from original mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.subdivide">
<code class="descname">subdivide</code><span class="sig-paren">(</span><em>face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh, with each subdivided face replaced with four
smaller faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>face_index: (m,) int or None</strong></dt><dd><p>If None all faces of mesh will be subdivided
If (m,) int array of indices: only specified faces will be
subdivided. Note that in this case the mesh will generally
no longer be manifold, as the additional vertex on the midpoint
will not be used by the adjacent faces to the faces specified,
and an additional postprocessing step will be required to
make resulting mesh watertight</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.submesh">
<code class="descname">submesh</code><span class="sig-paren">(</span><em>faces_sequence</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces_sequence</strong><span class="classifier">sequence (m,) int</span></dt><dd><p>Face indices of mesh</p>
</dd>
<dt><strong>only_watertight</strong><span class="classifier">bool</span></dt><dd><p>Only return submeshes which are watertight</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool</span></dt><dd><p>Return a single mesh which has the faces appended.
if this flag is set, only_watertight is ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>if append</strong><span class="classifier">trimesh.Trimesh object</span></dt><dd></dd>
<dt><strong>else</strong><span class="classifier">list of trimesh.Trimesh objects</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry">
<code class="descname">symmetry</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>symmetry: None         No rotational symmetry</strong></dt><dd><p>‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry_axis">
<code class="descname">symmetry_axis</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis: (3,) float</strong></dt><dd><p>Axis around which a 2D profile
was revolved to generate this mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.symmetry_section">
<code class="descname">symmetry_section</code><a class="headerlink" href="#trimesh.base.Trimesh.symmetry_section" title="Permalink to this definition">¶</a></dt>
<dd><p>If a mesh has rotational symmetry, return the two
vectors which make up a section coordinate frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>section: (2, 3) float, vectors to take a section along</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary representation of the current mesh, with keys
that can be used as the kwargs for the Trimesh constructor, eg:</p>
<p>a = Trimesh(<a href="#id1"><span class="problematic" id="id2">**</span></a>other_mesh.to_dict())</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">dict</span></dt><dd><p>With keys that match trimesh constructor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles">
<code class="descname">triangles</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Actual triangles of the mesh (points, not indexes)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Points of triangle vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_center">
<code class="descname">triangles_center</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles_center</strong><span class="classifier">(len(self.faces), 3) float</span></dt><dd><p>Center of each triangular face</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_cross">
<code class="descname">triangles_cross</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>The cross product of two edges of each triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>crosses</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Cross product of each triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.triangles_tree">
<code class="descname">triangles_tree</code><a class="headerlink" href="#trimesh.base.Trimesh.triangles_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>An R-tree containing each face of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">rtree.index</span></dt><dd><p>Each triangle in self.faces has a rectangular cell</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>other</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean union between this mesh and n other meshes</p>
<dl class="simple">
<dt>other<span class="classifier">trimesh.Trimesh, or list of trimesh.Trimesh objects</span></dt><dd><p>Other meshes to union</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>union</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Union of self and other Trimesh objects</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.units">
<code class="descname">units</code><a class="headerlink" href="#trimesh.base.Trimesh.units" title="Permalink to this definition">¶</a></dt>
<dd><p>Definition of units for the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>Unit system mesh is in, or None if not defined</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.unmerge_vertices">
<code class="descname">unmerge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.unmerge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all face references so that every face contains
three unique vertex indices and no faces are adjacent.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_faces">
<code class="descname">update_faces</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>In many cases, we will want to remove specific faces.
However, there is additional bookkeeping to do this cleanly.
This function updates the set of faces with a validity mask,
as well as keeping track of normals and colors.</p>
<dl class="simple">
<dt>valid<span class="classifier">(m) int or (len(self.faces)) bool</span></dt><dd><p>Mask to remove faces</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.update_vertices">
<code class="descname">update_vertices</code><span class="sig-paren">(</span><em>mask</em>, <em>inverse=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.update_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Update vertices with a mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_mask</strong><span class="classifier">(len(self.vertices)) bool</span></dt><dd><p>Array of which vertices to keep</p>
</dd>
<dt><strong>inverse</strong><span class="classifier">(len(self.vertices)) int</span></dt><dd><p>Array to reconstruct vertex references
such as output by np.unique</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_adjacency_graph">
<code class="descname">vertex_adjacency_graph</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and their connections
in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph: networkx.Graph</strong></dt><dd><p>Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<p>mesh = trimesh.primitives.Box()
graph = mesh.vertex_adjacency_graph
graph.neighbors(0)
&gt; [1,2,3,4]</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_defects">
<code class="descname">vertex_defects</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_defect</strong><span class="classifier">(len(self.vertices), ) float</span></dt><dd><p>Vertex defect at the every vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_neighbors">
<code class="descname">vertex_neighbors</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex neighbors of each vertex of the mesh, determined from
the cached vertex_adjacency_graph, if already existent.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_neighbors</strong><span class="classifier">(len(self.vertices),) int</span></dt><dd><p>Represents immediate neighbors of each vertex along
the edge of a triangle</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">primitives</span><span class="o">.</span><span class="n">Box</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">vertex_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[1,2,3,4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertex_normals">
<code class="descname">vertex_normals</code><a class="headerlink" href="#trimesh.base.Trimesh.vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex normals of the mesh. If the normals were loaded
we check to make sure we have the same number of vertex
normals and vertices before returning them. If there are
no vertex normals defined or a shape mismatch we  calculate
the vertex normals from the mean normals of the faces the
vertex is used in.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_normals</strong><span class="classifier">(n,3) float</span></dt><dd><p>Represents the surface normal at each vertex.
Where n == len(self.vertices)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.vertices">
<code class="descname">vertices</code><a class="headerlink" href="#trimesh.base.Trimesh.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertices of the mesh.</p>
<p>This is regarded as core information which cannot be
generated from cache and as such is stored in self._data
which tracks the array for changes and clears cached
values of the mesh if this is altered.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in cartesian space referenced by self.faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.visual">
<code class="descname">visual</code><a class="headerlink" href="#trimesh.base.Trimesh.visual" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stored visuals for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>visual</strong><span class="classifier">ColorVisuals or TextureVisuals</span></dt><dd><p>Contains visual information about the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.base.Trimesh.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.base.Trimesh.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current mesh calculated using a surface
integral. If the current mesh isn’t watertight this is
garbage.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume</strong><span class="classifier">float</span></dt><dd><p>Volume of the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.base.Trimesh.voxelized">
<code class="descname">voxelized</code><span class="sig-paren">(</span><em>pitch</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.base.Trimesh.voxelized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Voxel object representing the current mesh
discretized into voxels at the specified pitch</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pitch</strong><span class="classifier">float</span></dt><dd><p>The edge length of a single voxel</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>voxelized</strong><span class="classifier">Voxel object</span></dt><dd><p>Representing the current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.boolean">
<span id="trimesh-boolean-module"></span><h2>trimesh.boolean module<a class="headerlink" href="#module-trimesh.boolean" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.boolean.boolean_automatic">
<code class="descclassname">trimesh.boolean.</code><code class="descname">boolean_automatic</code><span class="sig-paren">(</span><em>meshes</em>, <em>operation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.boolean_automatic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trimesh.boolean.difference">
<code class="descclassname">trimesh.boolean.</code><code class="descname">difference</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean difference between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshes: list of Trimesh object</strong></dt><dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt><dd><p>valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>difference: a - (other meshes), **kwargs for a Trimesh</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.intersection">
<code class="descclassname">trimesh.boolean.</code><code class="descname">intersection</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean intersection between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshes: list of Trimesh object</strong></dt><dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt><dd><p>valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intersection: **kwargs for a Trimesh object of the</strong></dt><dd><p>volume that is contained by all meshes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.boolean.union">
<code class="descclassname">trimesh.boolean.</code><code class="descname">union</code><span class="sig-paren">(</span><em>meshes</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.boolean.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the boolean union between a mesh an n other meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshes: list of Trimesh object</strong></dt><dd></dd>
<dt><strong>engine: string, which backend to use.</strong></dt><dd><p>valid choices are ‘blender’ or ‘scad’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>union: a + (other meshes), **kwargs for a Trimesh</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.bounds">
<span id="trimesh-bounds-module"></span><h2>trimesh.bounds module<a class="headerlink" href="#module-trimesh.bounds" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.bounds.contains">
<code class="descclassname">trimesh.bounds.</code><code class="descname">contains</code><span class="sig-paren">(</span><em>bounds</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Do an axis aligned bounding box check on a list of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">(2, dimension) float</span></dt><dd><p>Axis aligned bounding box</p>
</dd>
<dt><strong>points</strong><span class="classifier">(n, dimension) float</span></dt><dd><p>Points in space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points_inside</strong><span class="classifier">(n,) bool</span></dt><dd><p>True if points are inside the AABB</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.corners">
<code class="descclassname">trimesh.bounds.</code><code class="descname">corners</code><span class="sig-paren">(</span><em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pair of axis aligned bounds, return all
8 corners of the bounding box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">(2,3) or (2,2) float</span></dt><dd><p>Axis aligned bounds</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>corners</strong><span class="classifier">(8,3) float</span></dt><dd><p>Corner vertices of the cube</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.minimum_cylinder">
<code class="descclassname">trimesh.bounds.</code><code class="descname">minimum_cylinder</code><span class="sig-paren">(</span><em>obj</em>, <em>sample_count=6</em>, <em>angle_tol=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.minimum_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the approximate minimum volume cylinder which contains
a mesh or a a list of points.</p>
<p>Samples a hemisphere then uses scipy.optimize to pick the
final orientation of the cylinder.</p>
<p>A nice discussion about better ways to implement this is here:
<a class="reference external" href="https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf">https://www.staff.uni-mainz.de/schoemer/publications/ALGO00.pdf</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">trimesh.Trimesh, or (n, 3) float</span></dt><dd><p>Mesh object or points in space</p>
</dd>
<dt><strong>sample_count</strong><span class="classifier">int</span></dt><dd><p>How densely should we sample the hemisphere.
Angular spacing is 180 degrees / this number</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">dict</span></dt><dd><dl>
<dt>With keys:</dt><dd><p>‘radius’    : float, radius of cylinder
‘height’    : float, height of cylinder
‘transform’ : (4,4) float, transform from the origin</p>
<blockquote>
<div><p>to centered cylinder</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds">
<code class="descclassname">trimesh.bounds.</code><code class="descname">oriented_bounds</code><span class="sig-paren">(</span><em>obj</em>, <em>angle_digits=1</em>, <em>ordered=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the oriented bounding box for a Trimesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">trimesh.Trimesh, (n, 2) float, or (n, 3) float</span></dt><dd><p>Mesh object or points in 2D or 3D space</p>
</dd>
<dt><strong>angle_digits</strong><span class="classifier">int</span></dt><dd><p>How much angular precision do we want on our result.
Even with less precision the returned extents will cover
the mesh albeit with larger than minimal volume, and may
experience substantial speedups.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>to_origin</strong><span class="classifier">(4,4) float</span></dt><dd><p>Transformation matrix which will move the center of the
bounding box of the input mesh to the origin.</p>
</dd>
<dt><strong>extents: (3,) float</strong></dt><dd><p>The extents of the mesh once transformed with to_origin</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.bounds.oriented_bounds_2D">
<code class="descclassname">trimesh.bounds.</code><code class="descname">oriented_bounds_2D</code><span class="sig-paren">(</span><em>points</em>, <em>qhull_options='QbB'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.bounds.oriented_bounds_2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an oriented bounding box for an array of 2D points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,2) float</span></dt><dd><p>Points in 2D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(3,3) float</span></dt><dd><p>Homogenous 2D transformation matrix to move the
input points so that the axis aligned bounding box
is CENTERED AT THE ORIGIN.</p>
</dd>
<dt><strong>rectangle</strong><span class="classifier">(2,) float</span></dt><dd><p>Size of extents once input points are transformed
by transform</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.caching">
<span id="trimesh-caching-module"></span><h2>trimesh.caching module<a class="headerlink" href="#module-trimesh.caching" title="Permalink to this headline">¶</a></h2>
<div class="section" id="caching-py">
<h3>caching.py<a class="headerlink" href="#caching-py" title="Permalink to this headline">¶</a></h3>
<p>Functions and classes that help with tracking changes in ndarrays
and clearing cached values based on those changes.</p>
<dl class="class">
<dt id="trimesh.caching.Cache">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">Cache</code><span class="sig-paren">(</span><em>id_function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to cache values which will be stored until the
result of an ID function changes.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.Cache.clear" title="trimesh.caching.Cache.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>([exclude])</p></td>
<td><p>Remove all elements in the cache.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.caching.Cache.delete" title="trimesh.caching.Cache.delete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete</span></code></a>(key)</p></td>
<td><p>Remove a key from the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.Cache.id_set" title="trimesh.caching.Cache.id_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">id_set</span></code></a>()</p></td>
<td><p>Set the current ID to the value of the ID function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.caching.Cache.update" title="trimesh.caching.Cache.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(items)</p></td>
<td><p>Update the cache with a set of key, value pairs without checking id_function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.Cache.verify" title="trimesh.caching.Cache.verify"><code class="xref py py-obj docutils literal notranslate"><span class="pre">verify</span></code></a>()</p></td>
<td><p>Verify that the cached values are still for the same value of id_function and delete all stored items if the value of id_function has changed.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.Cache.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements in the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a key from the cache.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.id_set">
<code class="descname">id_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.id_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current ID to the value of the ID function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>items</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the cache with a set of key, value pairs without
checking id_function.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.Cache.verify">
<code class="descname">verify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.Cache.verify" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that the cached values are still for the same
value of id_function and delete all stored items if
the value of id_function has changed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.DataStore">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">DataStore</code><a class="headerlink" href="#trimesh.caching.DataStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to store multiple numpy arrays and track them all
for changes.</p>
<p>Operates like a dict that only stores numpy.ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mutable</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.DataStore.clear" title="trimesh.caching.DataStore.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p>Remove all data from the DataStore.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.caching.DataStore.crc" title="trimesh.caching.DataStore.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</p></td>
<td><p>Get a CRC reflecting everything in the DataStore.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.DataStore.fast_hash" title="trimesh.caching.DataStore.fast_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_hash</span></code></a>()</p></td>
<td><p>Get a CRC32 or xxhash.xxh64 reflecting the DataStore.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.caching.DataStore.is_empty" title="trimesh.caching.DataStore.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a>()</p></td>
<td><p>Is the current DataStore empty or not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.DataStore.md5" title="trimesh.caching.DataStore.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>Get an MD5 reflecting everything in the DataStore.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>update</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>values</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.DataStore.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all data from the DataStore.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC reflecting everything in the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>crc: int, CRC of data</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.fast_hash">
<code class="descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a CRC32 or xxhash.xxh64 reflecting the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hashed: int, checksum of data</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is the current DataStore empty or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>empty: bool, False if there are items in the DataStore</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 reflecting everything in the DataStore.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md5: str, MD5 in hexadecimal</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.caching.DataStore.mutable">
<code class="descname">mutable</code><a class="headerlink" href="#trimesh.caching.DataStore.mutable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.caching.DataStore.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.DataStore.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.caching.TrackedArray">
<em class="property">class </em><code class="descclassname">trimesh.caching.</code><code class="descname">TrackedArray</code><a class="headerlink" href="#trimesh.caching.TrackedArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
<p>Subclass of numpy.ndarray that provides hash methods
to track changes.</p>
<p>General method is to aggressively set ‘modified’ flags
on operations which might (but don’t necessarily) alter
the array, ideally we sometimes compute hashes when we
don’t need to, but we don’t return wrong hashes ever.</p>
<p>We store boolean modified flag for each hash type to
make checks fast even for queries of different hashes.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></dt><dd><p>Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></dt><dd><p>Base object if memory is from some other object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></dt><dd><p>An object to simplify the interaction of the array with the ctypes module.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></dt><dd><p>Python buffer object pointing to the start of the array’s data.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></dt><dd><p>Data-type of the array’s elements.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Information about the memory layout of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></dt><dd><p>A 1-D iterator over the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></dt><dd><p>The imaginary part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></dt><dd><p>Length of one array element in bytes.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></dt><dd><p>Total bytes consumed by the elements of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></dt><dd><p>Number of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></dt><dd><p>The real part of the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>Tuple of array dimensions.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>Number of elements in the array.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></dt><dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.TrackedArray.md5" title="trimesh.caching.TrackedArray.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>Return an MD5 hash of the current array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.caching.TrackedArray.crc" title="trimesh.caching.TrackedArray.crc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code></a>()</p></td>
<td><p>A zlib.crc32 or zlib.adler32 checksum of the current data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.caching.TrackedArray.fast_hash" title="trimesh.caching.TrackedArray.fast_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_hash</span></code></a>()</p></td>
<td><p>An xxhash.b64 hash of the array.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.caching.TrackedArray.crc">
<code class="descname">crc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.crc" title="Permalink to this definition">¶</a></dt>
<dd><p>A zlib.crc32 or zlib.adler32 checksum
of the current data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>crc: int, checksum from zlib.crc32 or zlib.adler32</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.fast_hash">
<code class="descname">fast_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.fast_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>An xxhash.b64 hash of the array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xx: int, xxhash.xxh64 hash of array.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.caching.TrackedArray.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.TrackedArray.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an MD5 hash of the current array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md5: str, hexadecimal MD5 of the array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.caching.cache_decorator">
<code class="descclassname">trimesh.caching.</code><code class="descname">cache_decorator</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.cache_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for class methods, replaces &#64;property
but will store and retrieve function return values
in object cache.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>function</strong><span class="classifier">method</span></dt><dd><p>This is used as a decorator:
<a href="#id3"><span class="problematic" id="id4">``</span></a>`
&#64;cache_decorator
def foo(self, things):</p>
<blockquote>
<div><p>return ‘happy days’</p>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.caching.tracked_array">
<code class="descclassname">trimesh.caching.</code><code class="descname">tracked_array</code><span class="sig-paren">(</span><em>array</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.caching.tracked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Properly subclass a numpy ndarray to track changes.</p>
<p>Avoids some pitfalls of subclassing by forcing contiguous
arrays, and does a view into a TrackedArray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">array- like object</span></dt><dd><p>To be turned into a TrackedArray</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype</span></dt><dd><p>Which dtype to use for the array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tracked</strong><span class="classifier">TrackedArray</span></dt><dd><p>Contains input array data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.collision">
<span id="trimesh-collision-module"></span><h2>trimesh.collision module<a class="headerlink" href="#module-trimesh.collision" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.collision.CollisionManager">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">CollisionManager</code><a class="headerlink" href="#trimesh.collision.CollisionManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A mesh-mesh collision manager.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.add_object" title="trimesh.collision.CollisionManager.add_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_object</span></code></a>(name, mesh[, transform])</p></td>
<td><p>Add an object to the collision manager.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_internal" title="trimesh.collision.CollisionManager.in_collision_internal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_internal</span></code></a>([return_names, …])</p></td>
<td><p>Check if any pair of objects in the manager collide with one another.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_other" title="trimesh.collision.CollisionManager.in_collision_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_other</span></code></a>(other_manager[, …])</p></td>
<td><p>Check if any object from this manager collides with any object from another manager.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.in_collision_single" title="trimesh.collision.CollisionManager.in_collision_single"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_collision_single</span></code></a>(mesh[, transform, …])</p></td>
<td><p>Check a single object for collisions against all objects in the manager.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_internal" title="trimesh.collision.CollisionManager.min_distance_internal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_internal</span></code></a>([return_names, …])</p></td>
<td><p>Get the minimum distance between any pair of objects in the manager.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_other" title="trimesh.collision.CollisionManager.min_distance_other"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_other</span></code></a>(other_manager[, …])</p></td>
<td><p>Get the minimum distance between any pair of objects, one in each manager.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.min_distance_single" title="trimesh.collision.CollisionManager.min_distance_single"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min_distance_single</span></code></a>(mesh[, transform, …])</p></td>
<td><p>Get the minimum distance between a single object and any object in the manager.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.remove_object" title="trimesh.collision.CollisionManager.remove_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_object</span></code></a>(name)</p></td>
<td><p>Delete an object from the collision manager.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.CollisionManager.set_transform" title="trimesh.collision.CollisionManager.set_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_transform</span></code></a>(name, transform)</p></td>
<td><p>Set the transform for one of the manager’s objects.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.collision.CollisionManager.add_object">
<code class="descname">add_object</code><span class="sig-paren">(</span><em>name</em>, <em>mesh</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.add_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an object to the collision manager.</p>
<p>If an object with the given name is already in the manager,
replace it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>An identifier for the object</p>
</dd>
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>The geometry of the collision object</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4,4) float</span></dt><dd><p>Homogenous transform matrix for the object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_internal">
<code class="descname">in_collision_internal</code><span class="sig-paren">(</span><em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any pair of objects in the manager collide with one another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, a set is returned containing the names
of all pairs of objects in collision.</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a list of ContactData is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_collision</strong><span class="classifier">bool</span></dt><dd><p>True if a collision occurred between any pair of objects
and False otherwise</p>
</dd>
<dt><strong>names</strong><span class="classifier">set of 2-tup</span></dt><dd><p>The set of pairwise collisions. Each tuple
contains two names in alphabetical order indicating
that the two corresponding objects are in collision.</p>
</dd>
<dt><strong>contacts</strong><span class="classifier">list of ContactData</span></dt><dd><p>All contacts detected</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_other">
<code class="descname">in_collision_other</code><span class="sig-paren">(</span><em>other_manager</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any object from this manager collides with any object
from another manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other_manager</strong><span class="classifier">CollisionManager</span></dt><dd><p>Another collision manager object</p>
</dd>
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, a set is returned containing the names
of all pairs of objects in collision.</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a list of ContactData is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_collision</strong><span class="classifier">bool</span></dt><dd><p>True if a collision occurred between any pair of objects
and False otherwise</p>
</dd>
<dt><strong>names</strong><span class="classifier">set of 2-tup</span></dt><dd><p>The set of pairwise collisions. Each tuple
contains two names (first from this manager,
second from the other_manager) indicating
that the two corresponding objects are in collision.</p>
</dd>
<dt><strong>contacts</strong><span class="classifier">list of ContactData</span></dt><dd><p>All contacts detected</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.in_collision_single">
<code class="descname">in_collision_single</code><span class="sig-paren">(</span><em>mesh</em>, <em>transform=None</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.in_collision_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a single object for collisions against all objects in the
manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>The geometry of the collision object</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4,4) float</span></dt><dd><p>Homogenous transform matrix</p>
</dd>
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, a set is returned containing the names
of all objects in collision with the object</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a list of ContactData is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_collision</strong><span class="classifier">bool</span></dt><dd><p>True if a collision occurs and False otherwise</p>
</dd>
<dt><strong>names</strong><span class="classifier">set of str</span></dt><dd><p>The set of names of objects that collided with the
provided one</p>
</dd>
<dt><strong>contacts</strong><span class="classifier">list of ContactData</span></dt><dd><p>All contacts detected</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_internal">
<code class="descname">min_distance_internal</code><span class="sig-paren">(</span><em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects in the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, a 2-tuple is returned containing the names
of the closest objects.</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a DistanceData object is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>Min distance between any two managed objects</p>
</dd>
<dt><strong>names</strong><span class="classifier">(2,) str</span></dt><dd><p>The names of the closest objects</p>
</dd>
<dt><strong>data</strong><span class="classifier">DistanceData</span></dt><dd><p>Extra data about the distance query</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_other">
<code class="descname">min_distance_other</code><span class="sig-paren">(</span><em>other_manager</em>, <em>return_names=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between any pair of objects,
one in each manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other_manager</strong><span class="classifier">CollisionManager</span></dt><dd><p>Another collision manager object</p>
</dd>
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, a 2-tuple is returned containing
the names of the closest objects.</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a DistanceData object is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>The min distance between a pair of objects,
one from each manager.</p>
</dd>
<dt><strong>names</strong><span class="classifier">2-tup of str</span></dt><dd><p>A 2-tuple containing two names (first from this manager,
second from the other_manager) indicating
the two closest objects.</p>
</dd>
<dt><strong>data</strong><span class="classifier">DistanceData</span></dt><dd><p>Extra data about the distance query</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.min_distance_single">
<code class="descname">min_distance_single</code><span class="sig-paren">(</span><em>mesh</em>, <em>transform=None</em>, <em>return_name=False</em>, <em>return_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.min_distance_single" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the minimum distance between a single object and any
object in the manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>The geometry of the collision object</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4,4) float</span></dt><dd><p>Homogenous transform matrix for the object</p>
</dd>
<dt><strong>return_names</strong><span class="classifier">bool</span></dt><dd><p>If true, return name of the closest object</p>
</dd>
<dt><strong>return_data</strong><span class="classifier">bool</span></dt><dd><p>If true, a DistanceData object is returned as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>Min distance between mesh and any object in the manager</p>
</dd>
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the object in the manager that was closest</p>
</dd>
<dt><strong>data</strong><span class="classifier">DistanceData</span></dt><dd><p>Extra data about the distance query</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.remove_object">
<code class="descname">remove_object</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.remove_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete an object from the collision manager.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The identifier for the object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.CollisionManager.set_transform">
<code class="descname">set_transform</code><span class="sig-paren">(</span><em>name</em>, <em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.CollisionManager.set_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transform for one of the manager’s objects.
This replaces the prior transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>An identifier for the object already in the manager</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4,4) float</span></dt><dd><p>A new homogenous transform matrix for the object</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.ContactData">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">ContactData</code><span class="sig-paren">(</span><em>names</em>, <em>contact</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a collision contact.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.collision.ContactData.point" title="trimesh.collision.ContactData.point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point</span></code></a></dt><dd><p>The 3D point of intersection for this contact.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.ContactData.index" title="trimesh.collision.ContactData.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(name)</p></td>
<td><p>Returns the index of the face in contact for the mesh with the given name.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.collision.ContactData.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.ContactData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the face in contact for the mesh with
the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the target object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>The index of the face in collison</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.collision.ContactData.point">
<code class="descname">point</code><a class="headerlink" href="#trimesh.collision.ContactData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of intersection for this contact.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point</strong><span class="classifier">(3,) float</span></dt><dd><p>The intersection point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.collision.DistanceData">
<em class="property">class </em><code class="descclassname">trimesh.collision.</code><code class="descname">DistanceData</code><span class="sig-paren">(</span><em>names</em>, <em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Data structure for holding information about a distance query.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.collision.DistanceData.distance" title="trimesh.collision.DistanceData.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a></dt><dd><p>Returns the distance between the two objects.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.collision.DistanceData.index" title="trimesh.collision.DistanceData.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(name)</p></td>
<td><p>Returns the index of the closest face for the mesh with the given name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.collision.DistanceData.point" title="trimesh.collision.DistanceData.point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point</span></code></a>(name)</p></td>
<td><p>The 3D point of closest distance on the mesh with the given name.</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.collision.DistanceData.distance">
<code class="descname">distance</code><a class="headerlink" href="#trimesh.collision.DistanceData.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance between the two objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>The euclidean distance between the objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the closest face for the mesh with
the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the target object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>The index of the face in collisoin.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.collision.DistanceData.point">
<code class="descname">point</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.DistanceData.point" title="Permalink to this definition">¶</a></dt>
<dd><p>The 3D point of closest distance on the mesh with the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the target object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>point</strong><span class="classifier">(3,) float</span></dt><dd><p>The closest point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.collision.mesh_to_BVH">
<code class="descclassname">trimesh.collision.</code><code class="descname">mesh_to_BVH</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.mesh_to_BVH" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a BVHModel object from a Trimesh object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Input geometry</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bvh</strong><span class="classifier">fcl.BVHModel</span></dt><dd><p>BVH of input geometry</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.collision.scene_to_collision">
<code class="descclassname">trimesh.collision.</code><code class="descname">scene_to_collision</code><span class="sig-paren">(</span><em>scene</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.collision.scene_to_collision" title="Permalink to this definition">¶</a></dt>
<dd><p>Create collision objects from a trimesh.Scene object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scene</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Scene to create collision objects for</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>manager</strong><span class="classifier">CollisionManager</span></dt><dd><p>CollisionManager for objects in scene</p>
</dd>
<dt><strong>objects: {node name: CollisionObject}</strong></dt><dd><p>Collision objects for nodes in scene</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.comparison">
<span id="trimesh-comparison-module"></span><h2>trimesh.comparison module<a class="headerlink" href="#module-trimesh.comparison" title="Permalink to this headline">¶</a></h2>
<div class="section" id="comparison-py">
<h3>comparison.py<a class="headerlink" href="#comparison-py" title="Permalink to this headline">¶</a></h3>
<p>Provide methods for quickly hashing and comparing meshes.</p>
<dl class="function">
<dt id="trimesh.comparison.face_ordering">
<code class="descclassname">trimesh.comparison.</code><code class="descname">face_ordering</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.face_ordering" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangles with three different length sides are
ordered in two ways:
[small edge, medium edge, large edge] (SML)
[small edge, large edge,  medium edge] (SLM)</p>
<p>This function returns [-1, 0, 1], depending on whether
the triangle is SML or SLM, and 0 if M == L.</p>
<p>The reason this is useful as it as a rare property that is
invariant to translation and rotation but changes when a
mesh is reflected or inverted. It is NOT invariant to
different tesselations of the same surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Source geometry to calculate ordering on</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>order</strong><span class="classifier">(len(mesh.faces), ) int</span></dt><dd><p>Is each face SML (-1), SLM (+1), or M==L (0)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.comparison.identifier_hash">
<code class="descclassname">trimesh.comparison.</code><code class="descname">identifier_hash</code><span class="sig-paren">(</span><em>identifier</em>, <em>sigfig=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash an identifier array to a specified number of
significant figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>identifier</strong><span class="classifier">(n,) float</span></dt><dd><p>Vector of properties</p>
</dd>
<dt><strong>sigfig</strong><span class="classifier">(n,) int</span></dt><dd><p>Number of sigfigs per property</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>md5</strong><span class="classifier">str</span></dt><dd><p>MD5 hash of identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.comparison.identifier_simple">
<code class="descclassname">trimesh.comparison.</code><code class="descname">identifier_simple</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.comparison.identifier_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a basic identifier for a mesh, consisting of properties
that have been hand tuned to be somewhat robust to rigid
transformations and different tesselations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>Source geometry</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>identifier</strong><span class="classifier">(6,) float</span></dt><dd><p>Identifying values of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.constants">
<span id="trimesh-constants-module"></span><h2>trimesh.constants module<a class="headerlink" href="#module-trimesh.constants" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="trimesh.constants.NumericalResolutionPath">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalResolutionPath</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalResolutionPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>res.seg_frac: when discretizing curves, what percentage of the drawing</dt><dd><p>scale should we aim to make a single segment</p>
</dd>
</dl>
<p>res.seg_angle: when discretizing curves, what angle should a section span
res.max_sections: when discretizing splines, what is the maximum number</p>
<blockquote>
<div><p>of segments per control point</p>
</div></blockquote>
<dl class="simple">
<dt>res.min_sections: when discretizing splines, what is the minimum number</dt><dd><p>of segments per control point</p>
</dd>
</dl>
<p>res.export: format string to use when exporting floating point vertices</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.NumericalToleranceMesh">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalToleranceMesh</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalToleranceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>tol.zero: consider floating point numbers less than this zero</p>
<dl class="simple">
<dt>tol.merge: when merging vertices, consider vertices closer than this</dt><dd><p>to be the same vertex. Here we use the same value (1e-8)
as SolidWorks uses, according to their documentation.</p>
</dd>
<dt>tol.planar: the maximum distance from a plane a point can be and</dt><dd><p>still be considered to be on the plane</p>
</dd>
</dl>
<p>tol.facet_threshold: threshold for two facets to be considered coplanar</p>
</dd></dl>

<dl class="class">
<dt id="trimesh.constants.NumericalTolerancePath">
<em class="property">class </em><code class="descclassname">trimesh.constants.</code><code class="descname">NumericalTolerancePath</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.NumericalTolerancePath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>tol.zero: consider floating point numbers less than this zero
tol.merge: when merging vertices, consider vertices closer than this</p>
<blockquote>
<div><p>to be the same vertex</p>
</div></blockquote>
<dl class="simple">
<dt>tol.planar: the maximum distance from a plane a point can be and</dt><dd><p>still be considered to be on the plane</p>
</dd>
<dt>tol.seg_frac: when simplifying line segments what percentage of the drawing</dt><dd><p>scale can a segment be and have a curve fitted</p>
</dd>
<dt>tol.seg_angle: when simplifying line segments to arcs, what angle</dt><dd><p>can a segment span to be acceptable.</p>
</dd>
<dt>tol.aspect_frac: when simplifying line segments to closed arcs (circles)</dt><dd><p>what percentage can the aspect ratio differfrom 1:1
before escaping the fit early</p>
</dd>
<dt>tol.radius_frac: when simplifying line segments to arcs, what percentage</dt><dd><p>of the fit radius can vertices deviate to be acceptable</p>
</dd>
<dt>tol.radius_min: when simplifying line segments to arcs, what is the minimum</dt><dd><p>radius multiplied by document scale for an acceptable fit</p>
</dd>
<dt>tol.radius_max: when simplifying line segments to arcs, what is the maximum</dt><dd><p>radius multiplied by document scale for an acceptable fit</p>
</dd>
<dt>tol.tangent: when simplifying line segments to curves, what is the maximum</dt><dd><p>angle the end sections can deviate from tangent that is acceptable.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.constants.log_time">
<code class="descclassname">trimesh.constants.</code><code class="descname">log_time</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.constants.log_time" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator for methods which will time the method
and then emit a log.debug message with the method name
and how long it took to execute.</p>
</dd></dl>

</div>
<div class="section" id="module-trimesh.convex">
<span id="trimesh-convex-module"></span><h2>trimesh.convex module<a class="headerlink" href="#module-trimesh.convex" title="Permalink to this headline">¶</a></h2>
<p>convex.py</p>
<p>Deal with creating and checking convex objects in 2, 3 and N dimensions.</p>
<p>Convex is defined as:
1) “Convex, meaning “curving out” or “extending outward” (compare to concave)
2) having an outline or surface curved like the exterior of a circle or sphere.
3) (of a polygon) having only interior angles measuring less than 180</p>
<dl class="function">
<dt id="trimesh.convex.adjacency_projections">
<code class="descclassname">trimesh.convex.</code><code class="descname">adjacency_projections</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.adjacency_projections" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a mesh is convex by projecting the vertices of
a triangle onto the normal of its adjacent face.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Input geometry</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>projection</strong><span class="classifier">(len(mesh.face_adjacency),) float</span></dt><dd><p>Distance of projection of adjacent vertex onto plane</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.convex_hull">
<code class="descclassname">trimesh.convex.</code><code class="descname">convex_hull</code><span class="sig-paren">(</span><em>obj</em>, <em>qhull_options='QbB Pp QJn'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new Trimesh object representing the convex hull of the
current mesh, with proper normals and watertight.
Requires scipy &gt;.12.</p>
<dl class="simple">
<dt>obj<span class="classifier">Trimesh, or (n,3) float</span></dt><dd><p>Mesh or cartesian points</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>convex</strong><span class="classifier">Trimesh</span></dt><dd><p>Mesh of convex hull</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.hull_points">
<code class="descclassname">trimesh.convex.</code><code class="descname">hull_points</code><span class="sig-paren">(</span><em>obj</em>, <em>qhull_options='QbB Pp'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.hull_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract a convex set of points from multiple input formats.</p>
<dl class="simple">
<dt>obj: Trimesh object</dt><dd><p>(n,d) points
(m,) Trimesh objects</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (o,d) convex set of points</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.convex.is_convex">
<code class="descclassname">trimesh.convex.</code><code class="descname">is_convex</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.convex.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a mesh is convex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Input geometry</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>convex</strong><span class="classifier">bool</span></dt><dd><p>Was passed mesh convex or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.creation">
<span id="trimesh-creation-module"></span><h2>trimesh.creation module<a class="headerlink" href="#module-trimesh.creation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creation-py">
<h3>creation.py<a class="headerlink" href="#creation-py" title="Permalink to this headline">¶</a></h3>
<p>Create meshes from primitives, or with operations.</p>
<dl class="function">
<dt id="trimesh.creation.annulus">
<code class="descclassname">trimesh.creation.</code><code class="descname">annulus</code><span class="sig-paren">(</span><em>r_min=1.0</em>, <em>r_max=2.0</em>, <em>height=1.0</em>, <em>sections=32</em>, <em>transform=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.annulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of an annular cylinder along Z,
centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>r_min</strong><span class="classifier">float</span></dt><dd><p>The inner radius of the annular cylinder</p>
</dd>
<dt><strong>r_max</strong><span class="classifier">float</span></dt><dd><p>The outer radius of the annular cylinder</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>The height of the annular cylinder</p>
</dd>
<dt><strong>sections</strong><span class="classifier">int</span></dt><dd><p>How many pie wedges should the annular cylinder have</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>passed to Trimesh to create annulus</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>annulus</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh of annular cylinder</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.axis">
<code class="descclassname">trimesh.creation.</code><code class="descname">axis</code><span class="sig-paren">(</span><em>origin_size=0.04</em>, <em>transform=None</em>, <em>origin_color=None</em>, <em>axis_radius=None</em>, <em>axis_length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an XYZ axis marker as a  Trimesh, which represents position
and orientation. If you set the origin size the other parameters
will be set relative to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transformation matrix</p>
</dd>
<dt><strong>origin_size</strong><span class="classifier">float</span></dt><dd><p>Radius of sphere that represents the origin</p>
</dd>
<dt><strong>origin_color</strong><span class="classifier">(3,) float or int, uint8 or float</span></dt><dd><p>Color of the origin</p>
</dd>
<dt><strong>axis_radius</strong><span class="classifier">float</span></dt><dd><p>Radius of cylinder that represents x, y, z axis</p>
</dd>
<dt><strong>axis_length: float</strong></dt><dd><p>Length of cylinder that represents x, y, z axis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>marker</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh geometry of axis indicators</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.box">
<code class="descclassname">trimesh.creation.</code><code class="descname">box</code><span class="sig-paren">(</span><em>extents=None</em>, <em>transform=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.box" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cuboid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>extents</strong><span class="classifier">float, or (3,) float</span></dt><dd><p>Edge lengths</p>
</dd>
<dt><strong>transform: (4, 4) float</strong></dt><dd><p>Transformation matrix</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>passed to Trimesh to create box</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>box</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Cuboid geometry in space</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.camera_marker">
<code class="descclassname">trimesh.creation.</code><code class="descname">camera_marker</code><span class="sig-paren">(</span><em>camera</em>, <em>marker_height=0.4</em>, <em>origin_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.camera_marker" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a visual marker for a camera object, including an axis and FOV.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>camera</strong><span class="classifier">trimesh.scene.Camera</span></dt><dd><p>Camera object with FOV and transform defined</p>
</dd>
<dt><strong>marker_height</strong><span class="classifier">float</span></dt><dd><p>How far along the camera Z should FOV indicators be</p>
</dd>
<dt><strong>origin_size</strong><span class="classifier">float</span></dt><dd><p>Sphere radius of the origin (default: marker_height / 10.0)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>meshes</strong><span class="classifier">list</span></dt><dd><p>Contains Trimesh and Path3D objects which can be visualized</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.capsule">
<code class="descclassname">trimesh.creation.</code><code class="descname">capsule</code><span class="sig-paren">(</span><em>height=1.0, radius=1.0, count=[32, 32]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a capsule, or a cylinder with hemispheric ends.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>Center to center distance of two spheres</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Radius of the cylinder and hemispheres</p>
</dd>
<dt><strong>count</strong><span class="classifier">(2,) int</span></dt><dd><p>Number of sections on latitude and longitude</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>capsule</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><dl class="simple">
<dt>Capsule geometry with:</dt><dd><ul class="simple">
<li><p>cylinder axis is along Z</p></li>
<li><p>one hemisphere is centered at the origin</p></li>
<li><p>other hemisphere is centered along the Z axis at height</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.cylinder">
<code class="descclassname">trimesh.creation.</code><code class="descname">cylinder</code><span class="sig-paren">(</span><em>radius=1.0</em>, <em>height=1.0</em>, <em>sections=32</em>, <em>segment=None</em>, <em>transform=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a mesh of a cylinder along Z centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius of the cylinder</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>The height of the cylinder</p>
</dd>
<dt><strong>sections</strong><span class="classifier">int</span></dt><dd><p>How many pie wedges should the cylinder have</p>
</dd>
<dt><strong>segment</strong><span class="classifier">(2, 3) float</span></dt><dd><p>Endpoints of axis, overrides transform and height</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transform to apply</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>passed to Trimesh to create cylinder</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cylinder: trimesh.Trimesh</strong></dt><dd><p>Resulting mesh of a cylinder</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">extrude_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>height</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a 3D mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>polygon</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>2D geometry to extrude</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>Distance to extrude polygon along Z</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>passed to Trimesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Resulting extrusion as watertight body</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.extrude_triangulation">
<code class="descclassname">trimesh.creation.</code><code class="descname">extrude_triangulation</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>height</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.extrude_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a 2D triangulation into a watertight Trimesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 2) float</span></dt><dd><p>2D vertices</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(m, 3) int</span></dt><dd><p>Triangle indexes of vertices</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>Distance to extrude triangulation</p>
</dd>
<dt><strong>**kwargs:</strong></dt><dd><p>passed to Trimesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh created from extrusion</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosahedron">
<code class="descclassname">trimesh.creation.</code><code class="descname">icosahedron</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosahedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an icosahedron, a 20 faced polyhedron.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ico</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Icosahederon centered at the origin.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.icosphere">
<code class="descclassname">trimesh.creation.</code><code class="descname">icosphere</code><span class="sig-paren">(</span><em>subdivisions=3</em>, <em>radius=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.icosphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an isophere centered at the origin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>subdivisions</strong><span class="classifier">int</span></dt><dd><p>How many times to subdivide the mesh.
Note that the number of faces will grow as function of
4 ** subdivisions, so you probably want to keep this under ~5</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Desired radius of sphere</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ico</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Meshed sphere</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.random_soup">
<code class="descclassname">trimesh.creation.</code><code class="descname">random_soup</code><span class="sig-paren">(</span><em>face_count=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.random_soup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random triangles as a Trimesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>face_count</strong><span class="classifier">int</span></dt><dd><p>Number of faces desired in mesh</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>soup</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Geometry with face_count random faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.sweep_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">sweep_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>path</em>, <em>angles=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.sweep_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a 2D shapely polygon into a 3D mesh along an
arbitrary 3D path. Doesn’t handle sharp curvature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>polygon</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>Profile to sweep along path</p>
</dd>
<dt><strong>path</strong><span class="classifier">(n, 3) float</span></dt><dd><p>A path in 3D</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(n,) float</span></dt><dd><p>Optional rotation angle relative to prior vertex
at each vertex</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Geometry of result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.triangulate_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">triangulate_polygon</code><span class="sig-paren">(</span><em>polygon</em>, <em>triangle_args='pq30'</em>, <em>engine='auto'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.triangulate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a shapely polygon create a triangulation using one
of the python interfaces to triangle.c:
&gt; pip install meshpy
&gt; pip install triangle</p>
<dl class="simple">
<dt>polygon<span class="classifier">Shapely.geometry.Polygon</span></dt><dd><p>Polygon object to be triangulated</p>
</dd>
<dt>triangle_args<span class="classifier">str</span></dt><dd><p>Passed to triangle.triangulate</p>
</dd>
<dt>engine<span class="classifier">str</span></dt><dd><p>‘meshpy’, ‘triangle’, or ‘auto’</p>
</dd>
<dt>kwargs: passed directly to meshpy.triangle.build:</dt><dd><dl class="simple">
<dt>triangle.build(mesh_info,</dt><dd><p>verbose=False,
refinement_func=None,
attributes=False,
volume_constraints=True,
max_volume=None,
allow_boundary_steiner=True,
allow_volume_steiner=True,
quality_meshing=True,
generate_edges=None,
generate_faces=False,
min_angle=None)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 2) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(n, 3) int</span></dt><dd><p>Index of vertices that make up triangles</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.uv_sphere">
<code class="descclassname">trimesh.creation.</code><code class="descname">uv_sphere</code><span class="sig-paren">(</span><em>radius=1.0, count=[32, 32], theta=None, phi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.uv_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a UV sphere (latitude + longitude) centered at the
origin. Roughly one order of magnitude faster than an
icosphere but slightly uglier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Radius of sphere</p>
</dd>
<dt><strong>count</strong><span class="classifier">(2,) int</span></dt><dd><p>Number of latitude and longitude lines</p>
</dd>
<dt><strong>theta</strong><span class="classifier">(n,) float</span></dt><dd><p>Optional theta angles in radians</p>
</dd>
<dt><strong>phi</strong><span class="classifier">(n,) float</span></dt><dd><p>Optional phi angles in radians</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh of UV sphere with specified parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.creation.validate_polygon">
<code class="descclassname">trimesh.creation.</code><code class="descname">validate_polygon</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.creation.validate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure an input can be returned as a valid polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">shapely.geometry.Polygon, str (wkb), or (n, 2) float</span></dt><dd><p>Object which might be a polygon</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>polygon</strong><span class="classifier">shapely.geometry.Polygon</span></dt><dd><p>Valid polygon object</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>If a valid finite- area polygon isn’t available</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.curvature">
<span id="trimesh-curvature-module"></span><h2>trimesh.curvature module<a class="headerlink" href="#module-trimesh.curvature" title="Permalink to this headline">¶</a></h2>
<div class="section" id="curvature-py">
<h3>curvature.py<a class="headerlink" href="#curvature-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh curvature.</p>
<dl class="function">
<dt id="trimesh.curvature.discrete_gaussian_curvature_measure">
<code class="descclassname">trimesh.curvature.</code><code class="descname">discrete_gaussian_curvature_measure</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_gaussian_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete gaussian curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>radius</strong><span class="classifier">float, the sphere radius</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gaussian_curvature: (n,) float, discrete gaussian curvature measure.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.discrete_mean_curvature_measure">
<code class="descclassname">trimesh.curvature.</code><code class="descname">discrete_mean_curvature_measure</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.discrete_mean_curvature_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the discrete mean curvature measure of a sphere centered
at a point as detailed in ‘Restricted Delaunay triangulations and normal
cycle’, Cohen-Steiner and Morvan.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>radius</strong><span class="classifier">float, the sphere radius</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean_curvature: (n,) float, discrete mean curvature measure.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.face_angles_sparse">
<code class="descclassname">trimesh.curvature.</code><code class="descname">face_angles_sparse</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.face_angles_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse matrix representation of the face angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse: scipy.sparse.coo_matrix with:</strong></dt><dd><p>dtype: float
shape: (len(mesh.vertices), len(mesh.faces))</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.line_ball_intersection">
<code class="descclassname">trimesh.curvature.</code><code class="descname">line_ball_intersection</code><span class="sig-paren">(</span><em>start_points</em>, <em>end_points</em>, <em>center</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.line_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the length of the intersection of a line segment with a ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start_points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>end_points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>center</strong><span class="classifier">(3,) float, the sphere center</span></dt><dd></dd>
<dt><strong>radius</strong><span class="classifier">float, the sphere radius</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lengths: (n,) float, the lengths.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.sphere_ball_intersection">
<code class="descclassname">trimesh.curvature.</code><code class="descname">sphere_ball_intersection</code><span class="sig-paren">(</span><em>R</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.sphere_ball_intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the surface area of the intersection of sphere of radius R centered
at (0, 0, 0) with a ball of radius r centered at (R, 0, 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>R</strong><span class="classifier">float, sphere radius</span></dt><dd></dd>
<dt><strong>r</strong><span class="classifier">float, ball radius</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area: float, the surface are.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.curvature.vertex_defects">
<code class="descclassname">trimesh.curvature.</code><code class="descname">vertex_defects</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.curvature.vertex_defects" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles
of every face that includes that vertex.</p>
<p>If a vertex is only included by coplanar triangles, this
will be zero. For convex regions this is positive, and
concave negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_defect</strong><span class="classifier">(len(self.vertices), ) float</span></dt><dd><p>Vertex defect at the every vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.decomposition">
<span id="trimesh-decomposition-module"></span><h2>trimesh.decomposition module<a class="headerlink" href="#module-trimesh.decomposition" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.decomposition.convex_decomposition">
<code class="descclassname">trimesh.decomposition.</code><code class="descname">convex_decomposition</code><span class="sig-paren">(</span><em>mesh</em>, <em>engine=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.decomposition.convex_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate convex decomposition of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:   Trimesh object</strong></dt><dd></dd>
<dt><strong>engine: string, which backend to use. Valid choice is ‘vhacd’.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_args: list, list of **kwargs for Trimeshes that are nearly</strong></dt><dd><p>convex and approximate the original.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.decomposition.decomposition_automatic">
<code class="descclassname">trimesh.decomposition.</code><code class="descname">decomposition_automatic</code><span class="sig-paren">(</span><em>mesh</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.decomposition.decomposition_automatic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-trimesh.geometry">
<span id="trimesh-geometry-module"></span><h2>trimesh.geometry module<a class="headerlink" href="#module-trimesh.geometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.geometry.align_vectors">
<code class="descclassname">trimesh.geometry.</code><code class="descname">align_vectors</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>return_angle=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.align_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a transform between two 3D vectors.</p>
<p>Implements the method described here:
<a class="reference external" href="http://ethaneade.com/rot_between_vectors.pdf">http://ethaneade.com/rot_between_vectors.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(3,) float</span></dt><dd><p>Source vector</p>
</dd>
<dt><strong>b</strong><span class="classifier">(3,) float</span></dt><dd><p>Target vector</p>
</dd>
<dt><strong>return_angle</strong><span class="classifier">bool</span></dt><dd><p>If True return the angle between the two vectors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Homogenous transform from a to b</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Angle between vectors in radians
Only returned if return_angle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.faces_to_edges">
<code class="descclassname">trimesh.geometry.</code><code class="descname">faces_to_edges</code><span class="sig-paren">(</span><em>faces</em>, <em>return_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.faces_to_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of faces (n,3), return a list of edges (n*3,2)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(n, 3) int</span></dt><dd><p>Vertex indices representing faces</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n*3, 2) int</span></dt><dd><p>Vertex indices representing edges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.index_sparse">
<code class="descclassname">trimesh.geometry.</code><code class="descname">index_sparse</code><span class="sig-paren">(</span><em>column_count</em>, <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.index_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sparse matrix for which vertices are contained in which faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse: scipy.sparse.coo_matrix of shape (column_count, len(faces))</strong></dt><dd><p>dtype is boolean</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: sparse = faces_sparse(len(mesh.vertices), mesh.faces)</p>
<p>In [2]: sparse.shape
Out[2]: (12, 20)</p>
<p>In [3]: mesh.faces.shape
Out[3]: (20, 3)</p>
<p>In [4]: mesh.vertices.shape
Out[4]: (12, 3)</p>
<p>In [5]: dense = sparse.toarray().astype(int)</p>
<p>In [6]: dense
Out[6]:
array([[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</p>
<blockquote>
<div><p>[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
[0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0],
[0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1],
[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0],
[0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0],
[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1],
[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1]])</p>
</div></blockquote>
<p>In [7]: dense.sum(axis=0)
Out[7]: array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.mean_vertex_normals">
<code class="descclassname">trimesh.geometry.</code><code class="descname">mean_vertex_normals</code><span class="sig-paren">(</span><em>vertex_count</em>, <em>faces</em>, <em>face_normals</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.mean_vertex_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Find vertex normals from the mean of the faces that contain
that vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertex_count</strong><span class="classifier">int</span></dt><dd><p>The number of vertices faces refer to</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(n, 3) int</span></dt><dd><p>List of vertex indices</p>
</dd>
<dt><strong>face_normals</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Normal vector for each face</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertex_normals</strong><span class="classifier">(vertex_count, 3) float</span></dt><dd><p>Normals for every vertex
Vertices unreferenced by faces will be zero.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.plane_transform">
<code class="descclassname">trimesh.geometry.</code><code class="descname">plane_transform</code><span class="sig-paren">(</span><em>origin</em>, <em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.plane_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the origin and normal of a plane find the transform
that will move that plane to be coplanar with the XY plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>origin</strong><span class="classifier">(3,) float</span></dt><dd><p>Point that lies on the plane</p>
</dd>
<dt><strong>normal</strong><span class="classifier">(3,) float</span></dt><dd><p>Vector that points along normal of plane</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transform: (4,4) float</strong></dt><dd><p>Transformation matrix to move points onto XY plane</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.triangulate_quads">
<code class="descclassname">trimesh.geometry.</code><code class="descname">triangulate_quads</code><span class="sig-paren">(</span><em>quads</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.triangulate_quads" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of quad faces, return them as triangle faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>quads: (n, 4) int</strong></dt><dd><p>Vertex indices of quad faces</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(m, 3) int</span></dt><dd><p>Vertex indices of triangular faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.geometry.vector_angle">
<code class="descclassname">trimesh.geometry.</code><code class="descname">vector_angle</code><span class="sig-paren">(</span><em>pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.geometry.vector_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the angles between pairs of unit vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">(n, 2, 3) float</span></dt><dd><p>Unit vector pairs</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angles</strong><span class="classifier">(n,) float</span></dt><dd><p>Angles between vectors in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.graph">
<span id="trimesh-graph-module"></span><h2>trimesh.graph module<a class="headerlink" href="#module-trimesh.graph" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph-py">
<h3>graph.py<a class="headerlink" href="#graph-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with graph operations. Primarily deal with graphs in (n,2)
edge list form, and abstract the backend graph library being used.</p>
<p>Currently uses networkx, scipy.sparse.csgraph, or graph_tool
backends.</p>
<dl class="function">
<dt id="trimesh.graph.connected_component_labels">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_component_labels</code><span class="sig-paren">(</span><em>edges</em>, <em>node_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_component_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Label graph nodes from an edge list, using scipy.sparse.csgraph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Edges of a graph</p>
</dd>
<dt><strong>node_count</strong><span class="classifier">int, or None</span></dt><dd><p>The largest node in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">(node_count,) int</span></dt><dd><p>Component labels for each node</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_components">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_components</code><span class="sig-paren">(</span><em>edges</em>, <em>min_len=1</em>, <em>nodes=None</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of connected nodes from an edge list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges:      (n,2) int, edges between nodes</strong></dt><dd></dd>
<dt><strong>nodes:      (m, ) int, list of nodes that exist</strong></dt><dd></dd>
<dt><strong>min_len:    int, minimum length of a component group to return</strong></dt><dd></dd>
<dt><strong>engine:     str, which graph engine to use.</strong></dt><dd><p>(‘networkx’, ‘scipy’, or ‘graphtool’)
If None, will automatically choose fastest available.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>components: (n,) sequence of lists, nodes which are connected</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.connected_edges">
<code class="descclassname">trimesh.graph.</code><code class="descname">connected_edges</code><span class="sig-paren">(</span><em>G</em>, <em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.connected_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given graph G and list of nodes, return the list of edges that
are connected to nodes</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.edges_to_coo">
<code class="descclassname">trimesh.graph.</code><code class="descname">edges_to_coo</code><span class="sig-paren">(</span><em>edges</em>, <em>count=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.edges_to_coo" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, return a boolean scipy.sparse.coo_matrix
representing the edges in matrix form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n,2) int</span></dt><dd><p>Edges of a graph</p>
</dd>
<dt><strong>count</strong><span class="classifier">int</span></dt><dd><p>The total number of nodes in the graph
if None: count = edges.max() + 1</p>
</dd>
<dt><strong>data</strong><span class="classifier">(n,) any</span></dt><dd><p>Assign data to each edge, if None will
be bool True for each specified edge</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix: (count, count) scipy.sparse.coo_matrix</strong></dt><dd><p>Sparse COO</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency</code><span class="sig-paren">(</span><em>faces=None</em>, <em>mesh=None</em>, <em>return_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an (n,2) list of face indices.
Each pair of faces in the list shares an edge, making them adjacent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>faces</strong><span class="classifier">(n, 3) int, or None</span></dt><dd><p>List of vertex indices representing triangles</p>
</dd>
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>If passed will used cached edges instead of faces</p>
</dd>
<dt><strong>return_edges</strong><span class="classifier">bool</span></dt><dd><p>Return the edges shared by adjacent faces</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>adjacency</strong><span class="classifier">(m,2) int</span></dt><dd><p>Indexes of faces that are adjacent</p>
</dd>
<dt><strong>edges: (m,2) int</strong></dt><dd><p>Only returned if return_edges is True
Indexes of vertices which make up the
edges shared by the adjacent faces</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for lots of things such as finding
face- connected components:
&gt;&gt;&gt; graph = nx.Graph()
&gt;&gt;&gt; graph.add_edges_from(mesh.face_adjacency)
&gt;&gt;&gt; groups = nx.connected_components(graph_connected)</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_radius">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency_radius</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an approximate radius between adjacent faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>radii</strong><span class="classifier">(len(self.face_adjacency),) float</span></dt><dd><p>Approximate radius between faces
Parallel faces will have a value of np.inf</p>
</dd>
<dt><strong>span</strong><span class="classifier">(len(self.face_adjacency),) float</span></dt><dd><p>Perpendicular projection distance of two
unshared vertices onto the shared edge</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.face_adjacency_unshared">
<code class="descclassname">trimesh.graph.</code><code class="descname">face_adjacency_unshared</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.face_adjacency_unshared" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex index of the two vertices not in the shared
edge between two adjacent faces</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vid_unshared</strong><span class="classifier">(len(mesh.face_adjacency), 2) int</span></dt><dd><p>Indexes of mesh.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.facets">
<code class="descclassname">trimesh.graph.</code><code class="descname">facets</code><span class="sig-paren">(</span><em>mesh</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the list of parallel adjacent faces.</p>
<p>mesh :  trimesh.Trimesh
engine : str</p>
<blockquote>
<div><p>Which graph engine to use:
(‘scipy’, ‘networkx’, ‘graphtool’)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>facets</strong><span class="classifier">sequence of (n,) int</span></dt><dd><p>Groups of face indexes of
parallel adjacent faces.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.fill_traversals">
<code class="descclassname">trimesh.graph.</code><code class="descname">fill_traversals</code><span class="sig-paren">(</span><em>traversals</em>, <em>edges</em>, <em>edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.fill_traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a traversal of a list of edges into a sequence of
traversals where every pair of consecutive node indexes
is an edge in a passed edge list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>traversals</strong><span class="classifier">sequence of (m,) int</span></dt><dd><p>Node indexes of traversals of a graph</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Pairs of connected node indexes</p>
</dd>
<dt><strong>edges_hash</strong><span class="classifier">None, or (n,) int</span></dt><dd><p>Edges sorted along axis 1 then hashed
using grouping.hashable_rows</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>splits</strong><span class="classifier">sequence of (p,) int</span></dt><dd><p>Node indexes of connected traversals</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.graph_to_svg">
<code class="descclassname">trimesh.graph.</code><code class="descname">graph_to_svg</code><span class="sig-paren">(</span><em>graph</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.graph_to_svg" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a networkx graph into an SVG string, using graphviz dot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph: networkx graph</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>svg: string, pictoral layout in SVG format</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.is_watertight">
<code class="descclassname">trimesh.graph.</code><code class="descname">is_watertight</code><span class="sig-paren">(</span><em>edges</em>, <em>edges_sorted=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.is_watertight" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>edges<span class="classifier">(n, 2) int</span></dt><dd><p>List of vertex indices</p>
</dd>
<dt>edges_sorted<span class="classifier">(n, 2) int</span></dt><dd><p>Pass vertex indices sorted on axis 1 as a speedup</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>watertight</strong><span class="classifier">boolean</span></dt><dd><p>Whether every edge is shared by an even
number of faces</p>
</dd>
<dt><strong>winding</strong><span class="classifier">boolean</span></dt><dd><p>Whether every shared edge is reversed</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_collect">
<code class="descclassname">trimesh.graph.</code><code class="descname">multigraph_collect</code><span class="sig-paren">(</span><em>G</em>, <em>traversal</em>, <em>attrib=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a MultiDiGraph traversal, collect attributes along it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G:          networkx.MultiDiGraph</strong></dt><dd></dd>
<dt><strong>traversal:  (n) list of (node, instance) tuples</strong></dt><dd></dd>
<dt><strong>attrib:     dict key, name to collect. If None, will return all</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collected: (len(traversal) - 1) list of attributes</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.multigraph_paths">
<code class="descclassname">trimesh.graph.</code><code class="descname">multigraph_paths</code><span class="sig-paren">(</span><em>G</em>, <em>source</em>, <em>cutoff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.multigraph_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>For a networkx MultiDiGraph, find all paths from a source node
to leaf nodes. This function returns edge instance numbers
in addition to nodes, unlike networkx.all_simple_paths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G: networkx.MultiDiGraph</strong></dt><dd></dd>
<dt><strong>source: str, node to start off</strong></dt><dd></dd>
<dt><strong>cutoff: int, number of nodes to visit</strong></dt><dd><p>if None, will</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>traversals: (n,) list of [(node, edge instance index), ] paths</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.shared_edges">
<code class="descclassname">trimesh.graph.</code><code class="descname">shared_edges</code><span class="sig-paren">(</span><em>faces_a</em>, <em>faces_b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.shared_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two sets of faces, find the edges which are in both sets.</p>
<p>faces_a: (n,3) int, set of faces
faces_b: (m,3) int, set of faces</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shared: (p, 2) int, set of edges</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.smoothed">
<code class="descclassname">trimesh.graph.</code><code class="descname">smoothed</code><span class="sig-paren">(</span><em>mesh</em>, <em>angle</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.smoothed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a non- watertight version of the mesh which will
render nicely with smooth shading by disconnecting faces
at sharp angles to each other.</p>
<dl class="simple">
<dt>mesh<span class="classifier">trimesh.Trimesh</span></dt><dd><p>Source geometry</p>
</dd>
<dt>angle<span class="classifier">float</span></dt><dd><p>Angle in radians, adjacent faces which have normals
below this angle will be smoothed</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>smooth</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Geometry with disconnected face patches</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split">
<code class="descclassname">trimesh.graph.</code><code class="descname">split</code><span class="sig-paren">(</span><em>mesh</em>, <em>only_watertight=True</em>, <em>adjacency=None</em>, <em>engine=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a mesh into multiple meshes from face connectivity.</p>
<p>If only_watertight is true, it will only return watertight meshes
and will attempt single triangle/quad repairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh</strong></dt><dd></dd>
<dt><strong>only_watertight: if True, only return watertight components</strong></dt><dd></dd>
<dt><strong>adjacency: (n,2) list of face adjacency to override using the plain</strong></dt><dd><p>adjacency calculated automatically.</p>
</dd>
<dt><strong>engine: str, which engine to use. (‘networkx’, ‘scipy’, or ‘graphtool’)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>meshes: list of Trimesh objects</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.split_traversal">
<code class="descclassname">trimesh.graph.</code><code class="descname">split_traversal</code><span class="sig-paren">(</span><em>traversal</em>, <em>edges</em>, <em>edges_hash=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.split_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a traversal as a list of nodes, split the traversal
if a sequential index pair is not in the given edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n, 2) int</span></dt><dd><p>Graph edge indexes</p>
</dd>
<dt><strong>traversal</strong><span class="classifier">(m,) int</span></dt><dd><p>Traversal through edges</p>
</dd>
<dt><strong>edge_hash</strong><span class="classifier">(n,)</span></dt><dd><p>Edges sorted on axis=1 and
passed to grouping.hashable_rows</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>split</strong><span class="classifier">sequence of (p,) int</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.traversals">
<code class="descclassname">trimesh.graph.</code><code class="descname">traversals</code><span class="sig-paren">(</span><em>edges</em>, <em>mode='bfs'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.traversals" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an edge list, generate a sequence of ordered
depth first search traversals, using scipy.csgraph routines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">(n,2) int, undirected edges of a graph</span></dt><dd></dd>
<dt><strong>mode</strong><span class="classifier">str, ‘bfs’, or ‘dfs’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>traversals: (m,) sequence of (p,) int,</strong></dt><dd><p>ordered DFS or BFS traversals of the graph.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.graph.vertex_adjacency_graph">
<code class="descclassname">trimesh.graph.</code><code class="descname">vertex_adjacency_graph</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.graph.vertex_adjacency_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a networkx graph representing the vertices and
their connections in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">networkx.Graph</span></dt><dd><p>Graph representing vertices and edges between
them where vertices are nodes and edges are edges</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This is useful for getting nearby vertices for a given vertex,
potentially for some simple smoothing techniques.
&gt;&gt;&gt; graph = mesh.vertex_adjacency_graph
&gt;&gt;&gt; graph.neighbors(0)
&gt; [1,3,4]</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.grouping">
<span id="trimesh-grouping-module"></span><h2>trimesh.grouping module<a class="headerlink" href="#module-trimesh.grouping" title="Permalink to this headline">¶</a></h2>
<div class="section" id="grouping-py">
<h3>grouping.py<a class="headerlink" href="#grouping-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for grouping values and rows.</p>
<dl class="function">
<dt id="trimesh.grouping.blocks">
<code class="descclassname">trimesh.grouping.</code><code class="descname">blocks</code><span class="sig-paren">(</span><em>data</em>, <em>min_len=2</em>, <em>max_len=inf</em>, <em>digits=None</em>, <em>only_nonzero=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array, find the indices of contiguous blocks
of equal values.</p>
<p>data:    (n) array
min_len: int, the minimum length group to be returned
max_len: int, the maximum length group to be retuurned
digits:  if dealing with floats, how many digits to use
only_nonzero: bool, only return blocks of non- zero values</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>blocks: (m) sequence of indices referencing data</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.boolean_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">boolean_rows</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>operation=&lt;function intersect1d&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.boolean_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the rows in two arrays which occur in both rows.</p>
<dl class="simple">
<dt>a: (n, d) int</dt><dd><p>Array with row vectors</p>
</dd>
<dt>b: (m, d) int</dt><dd><p>Array with row vectors</p>
</dd>
<dt>operation<span class="classifier">function</span></dt><dd><dl class="simple">
<dt>Numpy boolean set operation function:</dt><dd><p>-np.intersect1d
-np.setdiff1d</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shared: (p, d) array containing rows in both a and b</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.clusters">
<code class="descclassname">trimesh.grouping.</code><code class="descname">clusters</code><span class="sig-paren">(</span><em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.clusters" title="Permalink to this definition">¶</a></dt>
<dd><p>Find clusters of points which have neighbours closer than radius</p>
<dl class="simple">
<dt>points<span class="classifier">(n, d) float</span></dt><dd><p>Points of dimension d</p>
</dd>
<dt>radius<span class="classifier">float</span></dt><dd><p>Max distance between points in a cluster</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>groups</strong><span class="classifier">(m,) sequence of int</span></dt><dd><p>Indices of points in a cluster</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.float_to_int">
<code class="descclassname">trimesh.grouping.</code><code class="descname">float_to_int</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em>, <em>dtype=&lt;class 'numpy.int32'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.float_to_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a numpy array of float/bool/int, return as integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(n, d) float, int, or bool</span></dt><dd><p>Input data</p>
</dd>
<dt><strong>digits</strong><span class="classifier">float or int</span></dt><dd><p>Precision for float conversion</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype</span></dt><dd><p>What datatype should result be returned as</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>as_int</strong><span class="classifier">(n, d) int</span></dt><dd><p>Data as integers</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group</code><span class="sig-paren">(</span><em>values</em>, <em>min_len=0</em>, <em>max_len=inf</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of values that are identical</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values:     1D array</strong></dt><dd></dd>
<dt><strong>min_len:    int, the shortest group allowed</strong></dt><dd><p>All groups will have len &gt;= min_length</p>
</dd>
<dt><strong>max_len:    int, the longest group allowed</strong></dt><dd><p>All groups will have len &lt;= max_length</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>groups: sequence of indices to form groups</strong></dt><dd><p>IE [0,1,0,1] returns [[0,2], [1,3]]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_distance">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_distance</code><span class="sig-paren">(</span><em>values</em>, <em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find groups of points which have neighbours closer than radius,
where no two points in a group are farther than distance apart.</p>
<dl class="simple">
<dt>points<span class="classifier">(n, d) float</span></dt><dd><p>Points of dimension d</p>
</dd>
<dt>distance<span class="classifier">float</span></dt><dd><p>Max distance between points in a cluster</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unique</strong><span class="classifier">(m, d) float</span></dt><dd><p>Median value of each group</p>
</dd>
<dt><strong>groups</strong><span class="classifier">(m) sequence of int</span></dt><dd><p>Indexes of points that make up a group</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_min">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_min</code><span class="sig-paren">(</span><em>groups</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of groups, find the minimum element of data within each group</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>groups</strong><span class="classifier">(n,) sequence of (q,) int</span></dt><dd><p>Indexes of each group corresponding to each element in data</p>
</dd>
<dt><strong>data</strong><span class="classifier">(m,)</span></dt><dd><p>The data that groups indexes reference</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>minimums</strong><span class="classifier">(n,)</span></dt><dd><p>Minimum value of data per group</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_rows</code><span class="sig-paren">(</span><em>data</em>, <em>require_count=None</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns index groups of duplicate rows, for example:
[[1,2], [3,4], [1,2]] will return [[0,2], [1]]</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data:          (n,m) array</strong></dt><dd></dd>
<dt><strong>require_count: only returns groups of a specified length, eg:</strong></dt><dd><p>require_count =  2
[[1,2], [3,4], [1,2]] will return [[0,2]]</p>
<p>Note that using require_count allows numpy advanced indexing
to be used in place of looping and checking hashes, and as a
consequence is ~10x faster.</p>
</dd>
<dt><strong>digits:        If data is floating point, how many decimals to look at.</strong></dt><dd><p>If this is None, the value in TOL_MERGE will be turned into a
digit count and used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>groups:        List or sequence of indices from data indicating identical rows.</strong></dt><dd><p>If require_count != None, shape will be (j, require_count)
If require_count is None, shape will be irregular (AKA a sequence)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.group_vectors">
<code class="descclassname">trimesh.grouping.</code><code class="descname">group_vectors</code><span class="sig-paren">(</span><em>vectors</em>, <em>angle=0.0001</em>, <em>include_negative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.group_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Group vectors based on an angle tolerance, with the option to
include negative vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">(n,3) float</span></dt><dd><p>Direction vector</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Group vectors closer than this angle in radians</p>
</dd>
<dt><strong>include_negative</strong><span class="classifier">bool</span></dt><dd><p>If True consider the same:
[0,0,1] and [0,0,-1]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_vectors</strong><span class="classifier">(m,3) float</span></dt><dd><p>Direction vector</p>
</dd>
<dt><strong>groups</strong><span class="classifier">(m,) sequence of int</span></dt><dd><p>Indices of source vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.hashable_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">hashable_rows</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.hashable_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>We turn our array into integers based on the precision
given by digits and then put them in a hashable format.</p>
<dl class="simple">
<dt>data<span class="classifier">(n, m) array</span></dt><dd><p>Input data</p>
</dd>
<dt>digits<span class="classifier">int or None</span></dt><dd><p>How many digits to add to hash if data is floating point
If None, tol.merge will be used</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hashable</strong><span class="classifier">(n,) array</span></dt><dd><p>Custom data type which can be sorted
or used as hash keys</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_runs">
<code class="descclassname">trimesh.grouping.</code><code class="descname">merge_runs</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_runs" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge duplicate sequential values. This differs from unique_ordered
in that values can occur in multiple places in the sequence, but
only consecutive repeats are removed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data: (n,) float or int</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged: (m,) float or int</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: a
Out[1]:
array([-1, -1, -1,  0,  0,  1,  1,  2,  0,</p>
<blockquote>
<div><p>3,  3,  4,  4,  5,  5,  6,  6,  7,
7,  8,  8,  9,  9,  9])</p>
</div></blockquote>
<p>In [2]: trimesh.grouping.merge_runs(a)
Out[2]: array([-1,  0,  1,  2,  0,  3,  4,  5,  6,  7,  8,  9])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.merge_vertices">
<code class="descclassname">trimesh.grouping.</code><code class="descname">merge_vertices</code><span class="sig-paren">(</span><em>mesh</em>, <em>digits=None</em>, <em>textured=True</em>, <em>uv_digits=4</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes duplicate vertices based on integer hashes of
each row.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd><p>Mesh to merge vertices on</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>How many digits to consider for vertices
If not specified uses tol.merge</p>
</dd>
<dt><strong>textured</strong><span class="classifier">bool</span></dt><dd><p>If True, for textured meshes only merge vertices
with identical positions AND UV coordinates.
No effect on untextured meshes</p>
</dd>
<dt><strong>uv_digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to consider for UV coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_float">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_float</code><span class="sig-paren">(</span><em>data</em>, <em>return_index=False</em>, <em>return_inverse=False</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Identical to the numpy.unique command, except evaluates floating point
numbers, using a specified number of digits.</p>
<p>If digits isn’t specified, the library default TOL_MERGE will be used.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_ordered">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_ordered</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the same as np.unique, but ordered as per the
first occurrence of the unique value in data.</p>
<p class="rubric">Examples</p>
<p>In [1]: a = [0, 3, 3, 4, 1, 3, 0, 3, 2, 1]</p>
<p>In [2]: np.unique(a)
Out[2]: array([0, 1, 2, 3, 4])</p>
<p>In [3]: trimesh.grouping.unique_ordered(a)
Out[3]: array([0, 3, 4, 1, 2])</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_rows">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_rows</code><span class="sig-paren">(</span><em>data</em>, <em>digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns indices of unique rows. It will return the
first occurrence of a row that is duplicated:
[[1,2], [3,4], [1,2]] will return [0,1]</p>
<p>data: (n,m) set of floating point data
digits: how many digits to consider for the purposes of uniqueness</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unique:  (j) array, index in data which is a unique row</strong></dt><dd></dd>
<dt><strong>inverse: (n) length array to reconstruct original</strong></dt><dd><p>example: unique[inverse] == data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.grouping.unique_value_in_row">
<code class="descclassname">trimesh.grouping.</code><code class="descname">unique_value_in_row</code><span class="sig-paren">(</span><em>data</em>, <em>unique=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.grouping.unique_value_in_row" title="Permalink to this definition">¶</a></dt>
<dd><p>For a 2D array of integers find the position of a value in each
row which only occurs once. If there are more than one value per
row which occur once, the last one is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data:   (n,d) int</strong></dt><dd></dd>
<dt><strong>unique: (m) int, list of unique values contained in data.</strong></dt><dd><p>speedup purposes only, generated from np.unique if not passed</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result: (n,d) bool, with one or zero True values per row.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<dl class="simple">
<dt>In [0]: r = np.array([[-1,  1,  1],</dt><dd><p>[-1,  1, -1],
[-1,  1,  1],
[-1,  1, -1],
[-1,  1, -1]], dtype=np.int8)</p>
</dd>
</dl>
<p>In [1]: unique_value_in_row(r)
Out[1]:</p>
<blockquote>
<div><dl class="simple">
<dt>array([[ True, False, False],</dt><dd><p>[False,  True, False],
[ True, False, False],
[False,  True, False],
[False,  True, False]], dtype=bool)</p>
</dd>
</dl>
</div></blockquote>
<p>In [2]: unique_value_in_row(r).sum(axis=1)
Out[2]: array([1, 1, 1, 1, 1])</p>
<p>In [3]: r[unique_value_in_row(r)]
Out[3]: array([-1,  1, -1,  1,  1], dtype=int8)</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.inertia">
<span id="trimesh-inertia-module"></span><h2>trimesh.inertia module<a class="headerlink" href="#module-trimesh.inertia" title="Permalink to this headline">¶</a></h2>
<div class="section" id="inertia-py">
<h3>inertia.py<a class="headerlink" href="#inertia-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with inertia tensors.</p>
<p>Results validated against known geometries and checked for
internal consistency.</p>
<dl class="function">
<dt id="trimesh.inertia.cylinder_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">cylinder_inertia</code><span class="sig-paren">(</span><em>mass</em>, <em>radius</em>, <em>height</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.cylinder_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a cylinder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mass</strong><span class="classifier">float</span></dt><dd><p>Mass of cylinder</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Radius of cylinder</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>Height of cylinder</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4,4) float</span></dt><dd><p>Transformation of cylinder</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inertia</strong><span class="classifier">(3,3) float</span></dt><dd><p>Inertia tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.principal_axis">
<code class="descclassname">trimesh.inertia.</code><code class="descname">principal_axis</code><span class="sig-paren">(</span><em>inertia</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.principal_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the principal components and principal axis
of inertia from the inertia tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inertia</strong><span class="classifier">(3,3) float</span></dt><dd><p>Inertia tensor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>components</strong><span class="classifier">(3,) float</span></dt><dd><p>Principal components of inertia</p>
</dd>
<dt><strong>vectors</strong><span class="classifier">(3,3) float</span></dt><dd><p>Row vectors pointing along the
principal axes of inertia</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.radial_symmetry">
<code class="descclassname">trimesh.inertia.</code><code class="descname">radial_symmetry</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.radial_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a mesh has rotational symmetry.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>symmetry</strong><span class="classifier">None or str</span></dt><dd><p>None         No rotational symmetry
‘radial’     Symmetric around an axis
‘spherical’  Symmetric around a point</p>
</dd>
<dt><strong>axis</strong><span class="classifier">None or (3,) float</span></dt><dd><p>Rotation axis or point</p>
</dd>
<dt><strong>section</strong><span class="classifier">None or (3, 2) float</span></dt><dd><p>If radial symmetry provide vectors
to get cross section</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.sphere_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">sphere_inertia</code><span class="sig-paren">(</span><em>mass</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.sphere_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inertia tensor of a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mass</strong><span class="classifier">float</span></dt><dd><p>Mass of sphere</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Radius of sphere</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inertia</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Inertia tensor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.inertia.transform_inertia">
<code class="descclassname">trimesh.inertia.</code><code class="descname">transform_inertia</code><span class="sig-paren">(</span><em>transform</em>, <em>inertia_tensor</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.inertia.transform_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an inertia tensor to a new frame.</p>
<p>More details in OCW PDF:
MIT16_07F09_Lec26.pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(3, 3) or (4, 4) float</span></dt><dd><p>Transformation matrix</p>
</dd>
<dt><strong>inertia_tensor</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Inertia tensor</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transformed</strong><span class="classifier">(3, 3) float</span></dt><dd><p>Inertia tensor in new frame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.integrate">
<span id="trimesh-integrate-module"></span><h2>trimesh.integrate module<a class="headerlink" href="#module-trimesh.integrate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integrate-py">
<h3>integrate.py<a class="headerlink" href="#integrate-py" title="Permalink to this headline">¶</a></h3>
<p>Utilities for integrating functions over meshes surfaces.</p>
<dl class="function">
<dt id="trimesh.integrate.substitute_barycentric">
<code class="descclassname">trimesh.integrate.</code><code class="descname">substitute_barycentric</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.substitute_barycentric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trimesh.integrate.symbolic_barycentric">
<code class="descclassname">trimesh.integrate.</code><code class="descname">symbolic_barycentric</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.integrate.symbolic_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Symbolically integrate a function(x,y,z) across a triangle or mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>function: string or sympy expression</strong></dt><dd><p>x, y, z will be replaced with a barycentric representation
and the the function is integrated across the triangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluator: numpy lambda function of result which takes a mesh</strong></dt><dd></dd>
<dt><strong>expr:      sympy expression of result</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: function = ‘1’</p>
<p>In [2]: integrator, expr = integrate_barycentric(function)</p>
<p>In [3]: integrator
Out[3]: &lt;__main__.evaluator instance at 0x7f66cd2a6200&gt;</p>
<p>In [4]: expr
Out[4]: 1/2</p>
<p>In [5]: result  = integrator(mesh)</p>
<p>In [6]: mesh.area
Out[6]: 34.641016151377542</p>
<p>In [7]: result.sum()
Out[7]: 34.641016151377542</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.intersections">
<span id="trimesh-intersections-module"></span><h2>trimesh.intersections module<a class="headerlink" href="#module-trimesh.intersections" title="Permalink to this headline">¶</a></h2>
<div class="section" id="intersections-py">
<h3>intersections.py<a class="headerlink" href="#intersections-py" title="Permalink to this headline">¶</a></h3>
<p>Primarily mesh-plane intersections (slicing).</p>
<dl class="function">
<dt id="trimesh.intersections.mesh_multiplane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">mesh_multiplane</code><span class="sig-paren">(</span><em>mesh</em>, <em>plane_origin</em>, <em>plane_normal</em>, <em>heights</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_multiplane" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility function for slicing a mesh by multiple
parallel planes, which caches the dot product operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Geometry to be sliced by planes</p>
</dd>
<dt><strong>plane_normal</strong><span class="classifier">(3,) float</span></dt><dd><p>Normal vector of plane</p>
</dd>
<dt><strong>plane_origin</strong><span class="classifier">(3,) float</span></dt><dd><p>Point on a plane</p>
</dd>
<dt><strong>heights</strong><span class="classifier">(m,) float</span></dt><dd><p>Offset distances from plane to slice at</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lines</strong><span class="classifier">(m,) sequence of (n, 2, 2) float</span></dt><dd><p>Lines in space for m planes</p>
</dd>
<dt><strong>to_3D</strong><span class="classifier">(m, 4, 4) float</span></dt><dd><p>Transform to move each section back to 3D</p>
</dd>
<dt><strong>face_index</strong><span class="classifier">(m,) sequence of (n,) int</span></dt><dd><p>Indexes of mesh.faces for each segment</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.mesh_plane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">mesh_plane</code><span class="sig-paren">(</span><em>mesh</em>, <em>plane_normal</em>, <em>plane_origin</em>, <em>return_faces=False</em>, <em>cached_dots=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.mesh_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a the intersections between a mesh and a plane,
returning a set of line segments on that plane.</p>
<dl class="simple">
<dt>mesh<span class="classifier">Trimesh object</span></dt><dd><p>Source mesh to slice</p>
</dd>
<dt>plane_normal<span class="classifier">(3,) float</span></dt><dd><p>Normal vector of plane to intersect with mesh</p>
</dd>
<dt>plane_origin:  (3,) float</dt><dd><p>Point on plane to intersect with mesh</p>
</dd>
<dt>return_faces:  bool</dt><dd><p>If True return face index each line is from</p>
</dd>
<dt>cached_dots<span class="classifier">(n, 3) float</span></dt><dd><p>If an external function has stored dot
products pass them here to avoid recomputing</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lines</strong><span class="classifier">(m, 2, 3) float</span></dt><dd><p>List of 3D line segments in space</p>
</dd>
<dt><strong>face_index</strong><span class="classifier">(m,) int</span></dt><dd><p>Index of mesh.faces for each line
Only returned if return_faces was True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.plane_lines">
<code class="descclassname">trimesh.intersections.</code><code class="descname">plane_lines</code><span class="sig-paren">(</span><em>plane_origin</em>, <em>plane_normal</em>, <em>endpoints</em>, <em>line_segments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.plane_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane-line intersections</p>
<dl class="simple">
<dt>plane_origin<span class="classifier">(3,) float</span></dt><dd><p>Point on plane</p>
</dd>
<dt>plane_normal<span class="classifier">(3,) float</span></dt><dd><p>Plane normal vector</p>
</dd>
<dt>endpoints<span class="classifier">(2, n, 3) float</span></dt><dd><p>Points defining lines to be tested</p>
</dd>
<dt>line_segments<span class="classifier">bool</span></dt><dd><p>If True, only returns intersections as valid if
vertices from endpoints are on different sides
of the plane.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>intersections</strong><span class="classifier">(m, 3) float</span></dt><dd><p>Cartesian intersection points</p>
</dd>
<dt><strong>valid</strong><span class="classifier">(n, 3) bool</span></dt><dd><p>Indicate whether a valid intersection exists
for each input line segment</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.planes_lines">
<code class="descclassname">trimesh.intersections.</code><code class="descname">planes_lines</code><span class="sig-paren">(</span><em>plane_origins</em>, <em>plane_normals</em>, <em>line_origins</em>, <em>line_directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.planes_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Given one line per plane, find the intersection points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>plane_origins</strong><span class="classifier">(n,3) float</span></dt><dd><p>Point on each plane</p>
</dd>
<dt><strong>plane_normals</strong><span class="classifier">(n,3) float</span></dt><dd><p>Normal vector of each plane</p>
</dd>
<dt><strong>line_origins</strong><span class="classifier">(n,3) float</span></dt><dd><p>Point at origin of each line</p>
</dd>
<dt><strong>line_directions</strong><span class="classifier">(n,3) float</span></dt><dd><p>Direction vector of each line</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>on_plane</strong><span class="classifier">(n,3) float</span></dt><dd><p>Points on specified planes</p>
</dd>
<dt><strong>valid</strong><span class="classifier">(n,) bool</span></dt><dd><p>Did plane intersect line or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.slice_faces_plane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">slice_faces_plane</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>plane_normal</em>, <em>plane_origin</em>, <em>cached_dots=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.slice_faces_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a mesh (given as a set of faces and vertices) with a plane, returning a
new mesh (again as a set of faces and vertices) that is the
portion of the original mesh to the positive normal side of the plane.</p>
<dl class="simple">
<dt>vertices<span class="classifier">(n, 3) float</span></dt><dd><p>Vertices of source mesh to slice</p>
</dd>
<dt>faces<span class="classifier">(n, 3) int</span></dt><dd><p>Faces of source mesh to slice</p>
</dd>
<dt>plane_normal<span class="classifier">(3,) float</span></dt><dd><p>Normal vector of plane to intersect with mesh</p>
</dd>
<dt>plane_origin:  (3,) float</dt><dd><p>Point on plane to intersect with mesh</p>
</dd>
<dt>cached_dots<span class="classifier">(n, 3) float</span></dt><dd><p>If an external function has stored dot
products pass them here to avoid recomputing</p>
</dd>
</dl>
<dl class="simple">
<dt>new_vertices<span class="classifier">(n, 3) float</span></dt><dd><p>Vertices of sliced mesh</p>
</dd>
<dt>new_faces<span class="classifier">(n, 3) int</span></dt><dd><p>Faces of sliced mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.intersections.slice_mesh_plane">
<code class="descclassname">trimesh.intersections.</code><code class="descname">slice_mesh_plane</code><span class="sig-paren">(</span><em>mesh</em>, <em>plane_normal</em>, <em>plane_origin</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.intersections.slice_mesh_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a mesh with a plane, returning a new mesh that is the
portion of the original mesh to the positive normal side of the plane</p>
<dl class="simple">
<dt>mesh<span class="classifier">Trimesh object</span></dt><dd><p>Source mesh to slice</p>
</dd>
<dt>plane_normal<span class="classifier">(3,) float</span></dt><dd><p>Normal vector of plane to intersect with mesh</p>
</dd>
<dt>plane_origin:  (3,) float</dt><dd><p>Point on plane to intersect with mesh</p>
</dd>
<dt>cached_dots<span class="classifier">(n, 3) float</span></dt><dd><p>If an external function has stored dot
products pass them here to avoid recomputing</p>
</dd>
</dl>
<dl class="simple">
<dt>new_mesh<span class="classifier">Trimesh object</span></dt><dd><p>Sliced mesh</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.interval">
<span id="trimesh-interval-module"></span><h2>trimesh.interval module<a class="headerlink" href="#module-trimesh.interval" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interval-py">
<h3>interval.py<a class="headerlink" href="#interval-py" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>Deal with 1D intervals which are defined by:</dt><dd><p>[start position, end position]</p>
</dd>
</dl>
<dl class="function">
<dt id="trimesh.interval.check">
<code class="descclassname">trimesh.interval.</code><code class="descname">check</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>digits</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.interval.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input ranges, convert them to vector form,
and get a fixed precision integer version of them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(2, ) or (2, n) float</span></dt><dd><p>Start and end of a 1D interval</p>
</dd>
<dt><strong>b</strong><span class="classifier">(2, ) or (2, n) float</span></dt><dd><p>Start and end of a 1D interval</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>How many digits to consider</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(2, n) float</span></dt><dd><p>Ranges as vector</p>
</dd>
<dt><strong>b</strong><span class="classifier">(2, n) float</span></dt><dd><p>Ranges as vector</p>
</dd>
<dt><strong>a_int</strong><span class="classifier">(2, n) int64</span></dt><dd><p>Ranges rounded to digits, as vector</p>
</dd>
<dt><strong>b_int</strong><span class="classifier">(2, n) int64</span></dt><dd><p>Ranges rounded to digits, as vector</p>
</dd>
<dt><strong>is_1D</strong><span class="classifier">bool</span></dt><dd><p>If True, input was single pair of ranges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.interval.intersection">
<code class="descclassname">trimesh.interval.</code><code class="descname">intersection</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>digits=8</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.interval.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a pair of ranges, merge them in to
one range if they overlap at all</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(2, ) float</span></dt><dd><p>Start and end of a 1D interval</p>
</dd>
<dt><strong>b</strong><span class="classifier">(2, ) float</span></dt><dd><p>Start and end of a 1D interval</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>How many digits to consider</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>intersects</strong><span class="classifier">bool or (n,) bool</span></dt><dd><p>Indicates if the ranges overlap at all</p>
</dd>
<dt><strong>new_range</strong><span class="classifier">(2, ) or (2, 2) float</span></dt><dd><p>The unioned range from the two inputs,
or both of the original ranges if not overlapping</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.nsphere">
<span id="trimesh-nsphere-module"></span><h2>trimesh.nsphere module<a class="headerlink" href="#module-trimesh.nsphere" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nsphere-py">
<h3>nsphere.py<a class="headerlink" href="#nsphere-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for fitting and minimizing nspheres:
circles, spheres, hyperspheres, etc.</p>
<dl class="function">
<dt id="trimesh.nsphere.fit_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">fit_nsphere</code><span class="sig-paren">(</span><em>points</em>, <em>prior=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.fit_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an n-sphere to a set of points using least squares.</p>
<dl class="simple">
<dt>points<span class="classifier">(n, d) float</span></dt><dd><p>Points in space</p>
</dd>
<dt>prior<span class="classifier">(d,) float</span></dt><dd><p>Best guess for center of nsphere</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>center</strong><span class="classifier">(d,) float</span></dt><dd><p>Location of center</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Mean radius across circle</p>
</dd>
<dt><strong>error</strong><span class="classifier">float</span></dt><dd><p>Peak to peak value of deviation from mean radius</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.is_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">is_nsphere</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.is_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a list of points is an nsphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (n,dimension) float, points in space</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>check: bool, True if input points are on an nsphere</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.nsphere.minimum_nsphere">
<code class="descclassname">trimesh.nsphere.</code><code class="descname">minimum_nsphere</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.nsphere.minimum_nsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum n- sphere for a mesh or a set of points.</p>
<p>Uses the fact that the minimum n- sphere will be centered at one of
the vertices of the furthest site voronoi diagram, which is n*log(n)
but should be pretty fast due to using the scipy/qhull implementations
of convex hulls and voronoi diagrams.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: Trimesh object OR</strong></dt><dd><p>(n,d) float, set of points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>center: (d) float, center of n- sphere</strong></dt><dd></dd>
<dt><strong>radius: float, radius of n-sphere</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.parent">
<span id="trimesh-parent-module"></span><h2>trimesh.parent module<a class="headerlink" href="#module-trimesh.parent" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parent-py">
<h3>parent.py<a class="headerlink" href="#parent-py" title="Permalink to this headline">¶</a></h3>
<p>The base class for Trimesh, PointCloud, and Scene objects</p>
<dl class="class">
<dt id="trimesh.parent.Geometry">
<em class="property">class </em><code class="descclassname">trimesh.parent.</code><code class="descname">Geometry</code><a class="headerlink" href="#trimesh.parent.Geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Parent of geometry classes.</p>
<p>The <cite>Geometry</cite> object is the parent object of geometry classes, including:
Trimesh, PointCloud, and Scene objects.</p>
<p>By decorating a method with <cite>abc.abstractmethod</cite> it just means the objects
that inherit from <cite>Geometry</cite> MUST implement those methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.parent.Geometry.bounding_box" title="trimesh.parent.Geometry.bounding_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></a></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.parent.Geometry.bounding_box_oriented" title="trimesh.parent.Geometry.bounding_box_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></a></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.parent.Geometry.bounding_cylinder" title="trimesh.parent.Geometry.bounding_cylinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></a></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.parent.Geometry.bounding_primitive" title="trimesh.parent.Geometry.bounding_primitive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></a></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.parent.Geometry.bounding_sphere" title="trimesh.parent.Geometry.bounding_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></a></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><strong>bounds</strong></dt><dd></dd>
<dt><strong>extents</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.parent.Geometry.apply_scale" title="trimesh.parent.Geometry.apply_scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code></a>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.parent.Geometry.apply_translation" title="trimesh.parent.Geometry.apply_translation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code></a>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 66%" />
<col style="width: 34%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>apply_transform</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>copy</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>is_empty</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>show</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.parent.Geometry.apply_scale">
<code class="descname">apply_scale</code><span class="sig-paren">(</span><em>scaling</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the mesh equally on all axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scaling</strong><span class="classifier">float</span></dt><dd><p>Scale factor to apply to the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.apply_translation">
<code class="descname">apply_translation</code><span class="sig-paren">(</span><em>translation</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.apply_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>translation</strong><span class="classifier">(3,) float</span></dt><dd><p>Translation in XYZ</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounding_box">
<code class="descname">bounding_box</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>An axis aligned bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>aabb</strong><span class="classifier">trimesh.primitives.Box</span></dt><dd><p>Box object with transform and extents defined
representing the axis aligned bounding box of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounding_box_oriented">
<code class="descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obb</strong><span class="classifier">trimesh.primitives.Box</span></dt><dd><p>Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounding_cylinder">
<code class="descname">bounding_cylinder</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding cylinder for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mincyl</strong><span class="classifier">trimesh.primitives.Cylinder</span></dt><dd><p>Cylinder primitive containing current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounding_primitive">
<code class="descname">bounding_primitive</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_primitive" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum volume primitive (box, sphere, or cylinder) that
bounds the mesh.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>bounding_primitive</strong><span class="classifier">trimesh.primitives.Sphere</span></dt><dd><blockquote>
<div><p>trimesh.primitives.Box
trimesh.primitives.Cylinder</p>
</div></blockquote>
<p>Primitive which bounds the mesh with the smallest volume</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounding_sphere">
<code class="descname">bounding_sphere</code><a class="headerlink" href="#trimesh.parent.Geometry.bounding_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>A minimum volume bounding sphere for the current mesh.</p>
<p>Note that the Sphere primitive returned has an unpadded, exact
sphere_radius so while the distance of every vertex of the current
mesh from sphere_center will be less than sphere_radius, the faceted
sphere primitive may not contain every vertex</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minball: trimesh.primitives.Sphere</strong></dt><dd><p>Sphere primitive containing current mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.parent.Geometry.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.parent.Geometry.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.parent.Geometry.extents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.is_empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.parent.Geometry.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.parent.Geometry.show" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.permutate">
<span id="trimesh-permutate-module"></span><h2>trimesh.permutate module<a class="headerlink" href="#module-trimesh.permutate" title="Permalink to this headline">¶</a></h2>
<div class="section" id="permutate-py">
<h3>permutate.py<a class="headerlink" href="#permutate-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly deform meshes in different ways.</p>
<dl class="class">
<dt id="trimesh.permutate.Permutator">
<em class="property">class </em><code class="descclassname">trimesh.permutate.</code><code class="descname">Permutator</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.permutate.Permutator.noise" title="trimesh.permutate.Permutator.noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">noise</span></code></a>([magnitude])</p></td>
<td><p>Add gaussian noise to every vertex of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.permutate.Permutator.tessellation" title="trimesh.permutate.Permutator.tessellation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tessellation</span></code></a>()</p></td>
<td><p>Subdivide each face of a mesh into three faces with the new vertex randomly placed inside the old face.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.permutate.Permutator.transform" title="trimesh.permutate.Permutator.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>()</p></td>
<td><p>Return a permutated variant of a mesh by randomly reording faces and rotatating + translating a mesh by a random matrix.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.permutate.Permutator.noise">
<code class="descname">noise</code><span class="sig-paren">(</span><em>magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh.
Makes no effort to maintain topology or sanity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:      Trimesh object (will not be mutated)</strong></dt><dd></dd>
<dt><strong>magnitude: float, what is the maximum distance per axis we can displace a vertex.</strong></dt><dd><p>Default value is mesh.scale/100.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object, input mesh with noise applied</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.tessellation">
<code class="descname">tessellation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object with remeshed facets</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.permutate.Permutator.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.Permutator.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:   Trimesh object (input will not be altered by this function)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object, same faces as input mesh but</strong></dt><dd><p>rotated and reordered.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.noise">
<code class="descclassname">trimesh.permutate.</code><code class="descname">noise</code><span class="sig-paren">(</span><em>mesh</em>, <em>magnitude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise to every vertex of a mesh.
Makes no effort to maintain topology or sanity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:      Trimesh object (will not be mutated)</strong></dt><dd></dd>
<dt><strong>magnitude: float, what is the maximum distance per axis we can displace a vertex.</strong></dt><dd><p>Default value is mesh.scale/100.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object, input mesh with noise applied</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.tessellation">
<code class="descclassname">trimesh.permutate.</code><code class="descname">tessellation</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.tessellation" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide each face of a mesh into three faces with the new vertex
randomly placed inside the old face.</p>
<p>This produces a mesh with exactly the same surface area and volume
but with different tessellation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object with remeshed facets</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.permutate.transform">
<code class="descclassname">trimesh.permutate.</code><code class="descname">transform</code><span class="sig-paren">(</span><em>mesh</em>, <em>translation_scale=1000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.permutate.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a permutated variant of a mesh by randomly reording faces
and rotatating + translating a mesh by a random matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:   Trimesh object (input will not be altered by this function)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>permutated: Trimesh object, same faces as input mesh but</strong></dt><dd><p>rotated and reordered.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.points">
<span id="trimesh-points-module"></span><h2>trimesh.points module<a class="headerlink" href="#module-trimesh.points" title="Permalink to this headline">¶</a></h2>
<div class="section" id="points-py">
<h3>points.py<a class="headerlink" href="#points-py" title="Permalink to this headline">¶</a></h3>
<p>Functions dealing with (n, d) points.</p>
<dl class="class">
<dt id="trimesh.points.PointCloud">
<em class="property">class </em><code class="descclassname">trimesh.points.</code><code class="descname">PointCloud</code><span class="sig-paren">(</span><em>vertices</em>, <em>colors=None</em>, <em>color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.parent.Geometry" title="trimesh.parent.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.parent.Geometry</span></code></a></p>
<p>Hold 3D points in an object which can be visualized
in a scene.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.bounds" title="trimesh.points.PointCloud.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt><dd><p>The axis aligned bounds of the PointCloud</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.centroid" title="trimesh.points.PointCloud.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></a></dt><dd><p>The mean vertex position</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.colors" title="trimesh.points.PointCloud.colors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">colors</span></code></a></dt><dd><p>Stored per- point color</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.convex_hull" title="trimesh.points.PointCloud.convex_hull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></a></dt><dd><p>A convex hull of every point.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.extents" title="trimesh.points.PointCloud.extents"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></a></dt><dd><p>The size of the axis aligned bounds</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.is_empty" title="trimesh.points.PointCloud.is_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></a></dt><dd><p>Are there any vertices defined or not.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.shape" title="trimesh.points.PointCloud.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Get the shape of the pointcloud</p>
</dd>
<dt><a class="reference internal" href="#trimesh.points.PointCloud.vertices" title="trimesh.points.PointCloud.vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></a></dt><dd><p>Vertices of the PointCloud</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.apply_transform" title="trimesh.points.PointCloud.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(transform)</p></td>
<td><p>Apply a homogenous transformation to the PointCloud object in- place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.copy" title="trimesh.points.PointCloud.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Safely get a copy of the current point cloud.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.md5" title="trimesh.points.PointCloud.md5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code></a>()</p></td>
<td><p>Get an MD5 hash of the current vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.merge_vertices" title="trimesh.points.PointCloud.merge_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code></a>()</p></td>
<td><p>Merge vertices closer than tol.merge (default: 1e-8)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.scene" title="trimesh.points.PointCloud.scene"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code></a>()</p></td>
<td><p>A scene containing just the PointCloud</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.points.PointCloud.show" title="trimesh.points.PointCloud.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>(**kwargs)</p></td>
<td><p>Open a viewer window displaying the current PointCloud</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.points.PointCloud.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a homogenous transformation to the PointCloud
object in- place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Homogenous transformation to apply to PointCloud</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.points.PointCloud.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">(2, 3) float</span></dt><dd><p>Miniumum, Maximum verteex</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.centroid">
<code class="descname">centroid</code><a class="headerlink" href="#trimesh.points.PointCloud.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean vertex position</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>centroid</strong><span class="classifier">(3,) float</span></dt><dd><p>Mean vertex position</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.colors">
<code class="descname">colors</code><a class="headerlink" href="#trimesh.points.PointCloud.colors" title="Permalink to this definition">¶</a></dt>
<dd><p>Stored per- point color</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>colors</strong><span class="classifier">(len(self.vertices), 4) np.uint8</span></dt><dd><p>Per- point RGBA color</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.convex_hull">
<code class="descname">convex_hull</code><a class="headerlink" href="#trimesh.points.PointCloud.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>A convex hull of every point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>convex_hull</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>A watertight mesh of the hull of the points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely get a copy of the current point cloud.</p>
<p>Copied objects will have emptied caches to avoid memory
issues and so may be slow on initial operations until
caches are regenerated.</p>
<p>Current object will <em>not</em> have its cache cleared.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>copied</strong><span class="classifier">trimesh.PointCloud</span></dt><dd><p>Copy of current point cloud</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.extents">
<code class="descname">extents</code><a class="headerlink" href="#trimesh.points.PointCloud.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the axis aligned bounds</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>extents</strong><span class="classifier">(3,) float</span></dt><dd><p>Edge length of axis aligned bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.is_empty">
<code class="descname">is_empty</code><a class="headerlink" href="#trimesh.points.PointCloud.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Are there any vertices defined or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>empty</strong><span class="classifier">bool</span></dt><dd><p>True if no vertices defined</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.md5">
<code class="descname">md5</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.md5" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an MD5 hash of the current vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>md5</strong><span class="classifier">str</span></dt><dd><p>Hash of self.vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.merge_vertices">
<code class="descname">merge_vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.merge_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge vertices closer than tol.merge (default: 1e-8)</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.scene">
<code class="descname">scene</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.scene" title="Permalink to this definition">¶</a></dt>
<dd><p>A scene containing just the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>scene</strong><span class="classifier">trimesh.Scene</span></dt><dd><p>Scene object containing this PointCloud</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.shape">
<code class="descname">shape</code><a class="headerlink" href="#trimesh.points.PointCloud.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the pointcloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">(2,) int</span></dt><dd><p>Shape of vertex array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.points.PointCloud.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.PointCloud.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a viewer window displaying the current PointCloud</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.points.PointCloud.vertices">
<code class="descname">vertices</code><a class="headerlink" href="#trimesh.points.PointCloud.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertices of the PointCloud</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in the PointCloud</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.points.k_means">
<code class="descclassname">trimesh.points.</code><code class="descname">k_means</code><span class="sig-paren">(</span><em>points</em>, <em>k</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.k_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Find k centroids that attempt to minimize the k- means problem:
<a class="reference external" href="https://en.wikipedia.org/wiki/Metric_k-center">https://en.wikipedia.org/wiki/Metric_k-center</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points:  (n, d) float</strong></dt><dd><p>Points in a space</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>Number of centroids to compute</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Passed directly to scipy.cluster.vq.kmeans</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centroids</strong><span class="classifier">(k, d) float</span></dt><dd><p>Points in some space</p>
</dd>
<dt><strong>labels: (n) int</strong></dt><dd><p>Indexes for which points belong to which centroid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.major_axis">
<code class="descclassname">trimesh.points.</code><code class="descname">major_axis</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.major_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an approximate vector representing the major axis of points</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (n, dimension) float, points in space</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>axis: (dimension,) float, vector along approximate major axis</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plane_fit">
<code class="descclassname">trimesh.points.</code><code class="descname">plane_fit</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plane_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, find an origin and normal using SVD.</p>
<dl class="simple">
<dt>points<span class="classifier">(n,3) float</span></dt><dd><p>Points in 3D space</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>C</strong><span class="classifier">(3,) float</span></dt><dd><p>Point on the plane</p>
</dd>
<dt><strong>N</strong><span class="classifier">(3,) float</span></dt><dd><p>Normal vector of plane</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.plot_points">
<code class="descclassname">trimesh.points.</code><code class="descname">plot_points</code><span class="sig-paren">(</span><em>points</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.plot_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot an (n,3) list of points using matplotlib</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>show</strong><span class="classifier">bool</span></dt><dd><p>If False, will not show until plt.show() is called</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.point_plane_distance">
<code class="descclassname">trimesh.points.</code><code class="descname">point_plane_distance</code><span class="sig-paren">(</span><em>points, plane_normal, plane_origin=[0.0, 0.0, 0.0]</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.point_plane_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum perpendicular distance of a point to a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points:       (n, 3) float, points in space</strong></dt><dd></dd>
<dt><strong>plane_normal: (3,) float, normal vector</strong></dt><dd></dd>
<dt><strong>plane_origin: (3,) float, plane origin in space</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distances:     (n,) float, distance from point to plane</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.project_to_plane">
<code class="descclassname">trimesh.points.</code><code class="descname">project_to_plane</code><span class="sig-paren">(</span><em>points, plane_normal=[0, 0, 1], plane_origin=[0, 0, 0], transform=None, return_transform=False, return_planar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.project_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects a set of (n,3) points onto a plane.</p>
<p>points:           (n,3) array of points
plane_normal:     (3) normal vector of plane
plane_origin:     (3) point on plane
transform:        None or (4,4) matrix. If specified, normal/origin are ignored
return_transform: bool, if true returns the (4,4) matrix used to project points</p>
<blockquote>
<div><p>onto a plane</p>
</div></blockquote>
<dl class="simple">
<dt>return_planar:    bool, if True, returns (n,2) points. If False, returns</dt><dd><p>(n,3), where the Z column consists of zeros</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.radial_sort">
<code class="descclassname">trimesh.points.</code><code class="descname">radial_sort</code><span class="sig-paren">(</span><em>points</em>, <em>origin</em>, <em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.radial_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts a set of points radially (by angle) around an
origin/normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (n,3) float, points in space</strong></dt><dd></dd>
<dt><strong>origin: (3,)  float, origin to sort around</strong></dt><dd></dd>
<dt><strong>normal: (3,)  float, vector to sort around</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ordered: (n,3) flot, re- ordered points in space</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.remove_close">
<code class="descclassname">trimesh.points.</code><code class="descname">remove_close</code><span class="sig-paren">(</span><em>points</em>, <em>radius</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.remove_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an (n, m) set of points where n=(2|3) return a list of points
where no point is closer than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, dimension) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>Minimum radius between result points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>culled</strong><span class="classifier">(m, dimension) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(n,) bool</span></dt><dd><p>Which points from the original set were returned</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.points.tsp">
<code class="descclassname">trimesh.points.</code><code class="descname">tsp</code><span class="sig-paren">(</span><em>points</em>, <em>start=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.points.tsp" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an ordering of points where each is visited and
the next point is the closest in euclidean distance,
and if there are multiple points with equal distance
go to an arbitrary one.</p>
<p>Assumes every point is visitable from every other point,
i.e. the travelling salesman problem on a fully connected
graph. It is not a MINIMUM traversal; rather it is a
“not totally goofy traversal, quickly.” On random points
this traversal is often ~20x shorter than random ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, dimension) float</span></dt><dd><p>ND points in space</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>The index of points we should start at</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>traversal</strong><span class="classifier">(n,) int</span></dt><dd><p>Ordered traversal visiting every point</p>
</dd>
<dt><strong>distances</strong><span class="classifier">(n - 1,) float</span></dt><dd><p>The euclidean distance between points in traversal</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.poses">
<span id="trimesh-poses-module"></span><h2>trimesh.poses module<a class="headerlink" href="#module-trimesh.poses" title="Permalink to this headline">¶</a></h2>
<div class="section" id="poses-py">
<h3>poses.py<a class="headerlink" href="#poses-py" title="Permalink to this headline">¶</a></h3>
<p>Find stable orientations of meshes.</p>
<dl class="function">
<dt id="trimesh.poses.compute_stable_poses">
<code class="descclassname">trimesh.poses.</code><code class="descname">compute_stable_poses</code><span class="sig-paren">(</span><em>mesh</em>, <em>center_mass=None</em>, <em>sigma=0.0</em>, <em>n_samples=1</em>, <em>threshold=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.poses.compute_stable_poses" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p>
<p>This method samples the location of the center of mass from a multivariate
gaussian with the mean at the center of mass, and a covariance
equal to and identity matrix times sigma, over n_samples.</p>
<p>For each sample, it computes the stable resting poses of the mesh on a
a planar workspace and evaulates the probabilities of landing in
each pose if the object is dropped onto the table randomly.</p>
<p>This method returns the 4x4 homogenous transform matrices that place
the shape against the planar surface with the z-axis pointing upwards
and a list of the probabilities for each pose.</p>
<p>The transforms and probabilties that are returned are sorted, with the
most probable pose first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:      Trimesh object, the target mesh</strong></dt><dd></dd>
<dt><strong>com:       (3,) float,     the object center of mass (if None, this method</strong></dt><dd><p>assumes uniform density and watertightness and
computes a center of mass explicitly)</p>
</dd>
<dt><strong>sigma:     float,          the covariance for the multivariate gaussian used</strong></dt><dd><p>to sample center of mass locations</p>
</dd>
<dt><strong>n_samples: int,            the number of samples of the center of mass loc</strong></dt><dd></dd>
<dt><strong>threshold: float,          the probability value at which to threshold</strong></dt><dd><p>returned stable poses</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>transforms: list of (4,4) floats, the homogenous matrices that transform the</strong></dt><dd><p>object to rest in a stable pose, with the
new z-axis pointing upwards from the table
and the object just touching the table.</p>
</dd>
<dt><strong>probs:      list of floats,       a probability in (0, 1) for each pose</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.primitives">
<span id="trimesh-primitives-module"></span><h2>trimesh.primitives module<a class="headerlink" href="#module-trimesh.primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="primitives-py">
<h3>primitives.py<a class="headerlink" href="#primitives-py" title="Permalink to this headline">¶</a></h3>
<p>Subclasses of Trimesh objects that are parameterized as primitives.</p>
<p>Useful because you can move boxes and spheres around, and then use
trimesh operations on them at any point.</p>
<dl class="class">
<dt id="trimesh.primitives.Box">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Box</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt><dd><p>Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Box.is_oriented" title="trimesh.primitives.Box.is_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_oriented</span></code></a></dt><dd><p>Returns whether or not the current box is rotated at all.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt><dd><p>Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Box.volume" title="trimesh.primitives.Box.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>Volume of the box Primitive.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</p></td>
<td><p>Apply a transform to the current primitive (sets self.transform)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the Primitive object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.primitives.Box.sample_grid" title="trimesh.primitives.Box.sample_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_grid</span></code></a>([count, step])</p></td>
<td><p>Return a 3D grid which is contained by the box.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.primitives.Box.sample_volume" title="trimesh.primitives.Box.sample_volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample_volume</span></code></a>(count)</p></td>
<td><p>Return random samples from inside the volume of the box.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</p></td>
<td><p>Return a copy of the Primitive object as a Trimesh object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Box.is_oriented">
<code class="descname">is_oriented</code><a class="headerlink" href="#trimesh.primitives.Box.is_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether or not the current box is rotated at all.</p>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_grid">
<code class="descname">sample_grid</code><span class="sig-paren">(</span><em>count=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 3D grid which is contained by the box.
Samples are either ‘step’ distance apart, or there are
‘count’ samples per box side.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>count: int   or (3,) int,   if specified samples are spaced with np.linspace</strong></dt><dd></dd>
<dt><strong>step:  float or (3,) float, if specified samples are spaced with np.arange</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>grid: (n,3) float, points inside the box</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Box.sample_volume">
<code class="descname">sample_volume</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Box.sample_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples from inside the volume of the box.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>count: int, number of samples to return</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples: (count,3) float, points inside the volume</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Box.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Box.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the box Primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume: float, volume of box</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Capsule">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Capsule</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt><dd><p>Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Capsule.direction" title="trimesh.primitives.Capsule.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt><dd><p>The direction of the capsule’s axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt><dd><p>Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></dt><dd><p>Volume of the current mesh calculated using a surface integral.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</p></td>
<td><p>Apply a transform to the current primitive (sets self.transform)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the Primitive object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</p></td>
<td><p>Return a copy of the Primitive object as a Trimesh object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Capsule.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Capsule.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the capsule’s axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis: (3,) float, vector along the cylinder axis</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Cylinder">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Cylinder</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></dt><dd><p>Summed area of all triangles in the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.direction" title="trimesh.primitives.Cylinder.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt><dd><p>The direction of the cylinder’s axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.moment_inertia" title="trimesh.primitives.Cylinder.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt><dd><p>The analytic inertia tensor of the cylinder primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Cylinder.volume" title="trimesh.primitives.Cylinder.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>The analytic volume of the cylinder primitive.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</p></td>
<td><p>Apply a transform to the current primitive (sets self.transform)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the Primitive object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</p></td>
<td><p>Return a copy of the Primitive object as a Trimesh object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Cylinder.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>The direction of the cylinder’s axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis: (3,) float, vector along the cylinder axis</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Cylinder.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the cylinder primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor: (3,3) float, 3D inertia tensor</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Cylinder.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Cylinder.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic volume of the cylinder primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume: float, volume of the cylinder</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Extrusion">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Extrusion</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.area" title="trimesh.primitives.Extrusion.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt><dd><p>The surface area of the primitive extrusion.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.direction" title="trimesh.primitives.Extrusion.direction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">direction</span></code></a></dt><dd><p>Based on the extrudes transform, what is the vector along</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></dt><dd><p>Return the moment of inertia matrix of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Extrusion.volume" title="trimesh.primitives.Extrusion.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>The volume of the primitive extrusion.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code>(matrix)</p></td>
<td><p>Apply a transform to the current primitive (sets self.transform)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.primitives.Extrusion.buffer" title="trimesh.primitives.Extrusion.buffer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">buffer</span></code></a>(distance)</p></td>
<td><p>Return a new Extrusion object which is expanded in profile and in height by a specified distance.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the Primitive object.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.primitives.Extrusion.slide" title="trimesh.primitives.Extrusion.slide"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slide</span></code></a>(distance)</p></td>
<td><p>Alter the transform of the current extrusion to slide it along its extrude_direction vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</p></td>
<td><p>Return a copy of the Primitive object as a Trimesh object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.primitives.Extrusion.area" title="Permalink to this definition">¶</a></dt>
<dd><p>The surface area of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area: float, surface area of 3D extrusion</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.buffer">
<code class="descname">buffer</code><span class="sig-paren">(</span><em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Extrusion object which is expanded in profile and
in height by a specified distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>buffered: Extrusion object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.direction">
<code class="descname">direction</code><a class="headerlink" href="#trimesh.primitives.Extrusion.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on the extrudes transform, what is the vector along
which the polygon will be extruded</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>direction: (3,) float vector. If self.primitive.transform is an</strong></dt><dd><p>identity matrix this will be [0.0, 0.0, 1.0]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.primitives.Extrusion.slide">
<code class="descname">slide</code><span class="sig-paren">(</span><em>distance</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Extrusion.slide" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the transform of the current extrusion to slide it
along its extrude_direction vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>distance: float, distance along self.extrude_direction to move</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Extrusion.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Extrusion.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>The volume of the primitive extrusion.</p>
<p>Calculated from polygon and height to avoid mesh creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume: float, volume of 3D extrusion</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.primitives.Sphere">
<em class="property">class </em><code class="descclassname">trimesh.primitives.</code><code class="descname">Sphere</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.primitives._Primitive</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.area" title="trimesh.primitives.Sphere.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a></dt><dd><p>Surface area of the current sphere primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_faces</span></code></dt><dd><p>The area of each face in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">body_count</span></code></dt><dd><p>How many connected groups of vertices exist in this mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box</span></code></dt><dd><p>An axis aligned bounding box for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.bounding_box_oriented" title="trimesh.primitives.Sphere.bounding_box_oriented"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_box_oriented</span></code></a></dt><dd><p>An oriented bounding box for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_cylinder</span></code></dt><dd><p>A minimum volume bounding cylinder for the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_primitive</span></code></dt><dd><p>The minimum volume primitive (box, sphere, or cylinder) that bounds the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounding_sphere</span></code></dt><dd><p>A minimum volume bounding sphere for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.bounds" title="trimesh.primitives.Sphere.bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bounds</span></code></a></dt><dd><p>The axis aligned bounds of the faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_mass</span></code></dt><dd><p>The point in space which is the center of mass/volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">centroid</span></code></dt><dd><p>The point in space which is the average of the triangle centroids weighted by the area of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_hull</span></code></dt><dd><p>Get a new Trimesh object representing the convex hull of the current mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></dt><dd><p>The density of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></dt><dd><p>Edges of the mesh (derived from faces).</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_face</span></code></dt><dd><p>Which face does each edge belong to.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sorted</span></code></dt><dd><p>Edges sorted along axis 1</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_sparse</span></code></dt><dd><p>Edges in sparse bool COO graph format where connected vertices are True.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique</span></code></dt><dd><p>The unique edges of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_inverse</span></code></dt><dd><p>Return the inverse required to reproduce self.edges_sorted from self.edges_unique.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges_unique_length</span></code></dt><dd><p>How long is each unique edge.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">euler_number</span></code></dt><dd><p>Return the Euler characteristic (a topological invariant) for the mesh</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">extents</span></code></dt><dd><p>The length, width, and height of the bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency</span></code></dt><dd><p>Find faces that share an edge, which we call here ‘adjacent’.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_angles</span></code></dt><dd><p>Return the angle between adjacent faces</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_convex</span></code></dt><dd><p>Return faces which are adjacent and locally convex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_edges</span></code></dt><dd><p>Returns the edges that are shared by the adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_projections</span></code></dt><dd><p>The projection of the non- shared vertex of a triangle onto</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_radius</span></code></dt><dd><p>The approximate radius of a cylinder that fits inside adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_span</span></code></dt><dd><p>The approximate perpendicular projection of the non- shared vertices in a pair of adjacent faces onto the shared edge of the two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_tree</span></code></dt><dd><p>An R-tree of face adjacencies.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_adjacency_unshared</span></code></dt><dd><p>Return the vertex index of the two vertices not in the shared</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles</span></code></dt><dd><p>Returns the angle at each vertex of a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_angles_sparse</span></code></dt><dd><p>A sparse matrix representation of the face angles.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">face_normals</span></code></dt><dd><p>Return the unit normal vector for each face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces</span></code></dt><dd><p>The faces of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_sparse</span></code></dt><dd><p>A sparse matrix representation of the faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">faces_unique_edges</span></code></dt><dd><p>For each face return which indexes in mesh.unique_edges constructs that face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets</span></code></dt><dd><p>Return a list of face indices for coplanar adjacent faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_area</span></code></dt><dd><p>Return an array containing the area of each facet.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_boundary</span></code></dt><dd><p>Return the edges which represent the boundary of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_normal</span></code></dt><dd><p>Return the normal of each facet</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_on_hull</span></code></dt><dd><p>Find which facets of the mesh are on the convex hull.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">facets_origin</span></code></dt><dd><p>Return a point on the facet plane.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier</span></code></dt><dd><p>Return a float vector which is unique to the mesh and is robust to rotation and translation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">identifier_md5</span></code></dt><dd><p>An MD5 of the rotation invariant identifier vector</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_convex</span></code></dt><dd><p>Check if a mesh is convex or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_empty</span></code></dt><dd><p>Does the current mesh have data defined.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_volume</span></code></dt><dd><p>Check if a mesh has all the properties required to represent a valid volume, rather than just a surface.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_watertight</span></code></dt><dd><p>Check if a mesh is watertight by making sure every edge is included in two faces.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_winding_consistent</span></code></dt><dd><p>Does the mesh have consistent winding or not.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdtree</span></code></dt><dd><p>Return a scipy.spatial.cKDTree of the vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></dt><dd><p>Mass of the current mesh, based on specified density and volume.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_properties</span></code></dt><dd><p>Returns the mass properties of the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.moment_inertia" title="trimesh.primitives.Sphere.moment_inertia"><code class="xref py py-obj docutils literal notranslate"><span class="pre">moment_inertia</span></code></a></dt><dd><p>The analytic inertia tensor of the sphere primitive.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_components</span></code></dt><dd><p>Return the principal components of inertia</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_transform</span></code></dt><dd><p>A transform which moves the current mesh so the principal inertia vectors are on the X,Y, and Z axis, and the centroid is at the origin.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_inertia_vectors</span></code></dt><dd><p>Return the principal axis of inertia.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">referenced_vertices</span></code></dt><dd><p>Which vertices in the current mesh are referenced by a face.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></dt><dd><p>A metric for the overall scale of the mesh, the length of the diagonal of the axis aligned bounding box of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry</span></code></dt><dd><p>Check whether a mesh has rotational symmetry.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_axis</span></code></dt><dd><p>If a mesh has rotational symmetry, return the axis.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">symmetry_section</span></code></dt><dd><p>If a mesh has rotational symmetry, return the two vectors which make up a section coordinate frame.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles</span></code></dt><dd><p>Actual triangles of the mesh (points, not indexes)</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_center</span></code></dt><dd><p>The center of each triangle (barycentric [1/3, 1/3, 1/3])</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_cross</span></code></dt><dd><p>The cross product of two edges of each triangle.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangles_tree</span></code></dt><dd><p>An R-tree containing each face of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Definition of units for the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_adjacency_graph</span></code></dt><dd><p>Returns a networkx graph representing the vertices and their connections in the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_defects</span></code></dt><dd><p>Return the vertex defects, or (2*pi) minus the sum of the angles of every face that includes that vertex.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_neighbors</span></code></dt><dd><p>The vertex neighbors of each vertex of the mesh, determined from the cached vertex_adjacency_graph, if already existent.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_normals</span></code></dt><dd><p>The vertex normals of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertices</span></code></dt><dd><p>The vertices of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">visual</span></code></dt><dd><p>Get the stored visuals for the current mesh.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.primitives.Sphere.volume" title="trimesh.primitives.Sphere.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>Volume of the current sphere primitive.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_obb</span></code>()</p></td>
<td><p>Apply the oriented bounding box transform to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_scale</span></code>(scaling)</p></td>
<td><p>Scale the mesh equally on all axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.primitives.Sphere.apply_transform" title="trimesh.primitives.Sphere.apply_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_transform</span></code></a>(matrix)</p></td>
<td><p>Apply a transform to the sphere primitive</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_translation</span></code>(translation)</p></td>
<td><p>Translate the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_stable_poses</span></code>([center_mass, sigma, …])</p></td>
<td><p>Computes stable orientations of a mesh and their quasi-static probabilites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code>(points)</p></td>
<td><p>Given a set of points, determine whether or not they are inside the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_units</span></code>(desired[, guess])</p></td>
<td><p>Convert the units of the mesh into a specified unit.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convex_decomposition</span></code>([engine, maxhulls])</p></td>
<td><p>Compute an approximate convex decomposition of a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p>Return a copy of the Primitive object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">crc</span></code>()</p></td>
<td><p>A zlib.adler32 checksum for the current mesh data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">difference</span></code>(other[, engine])</p></td>
<td><p>Boolean difference between this mesh and n other meshes</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_cached</span></code>(statement, *args)</p></td>
<td><p>Evaluate a statement and cache the result before returning.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">export</span></code>([file_obj, file_type])</p></td>
<td><p>Export the current mesh to a file object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>()</p></td>
<td><p>Fill single triangle and single quad holes in the current mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fix_normals</span></code>(**kwargs)</p></td>
<td><p>Find and fix problems with self.face_normals and self.faces winding direction.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection</span></code>(other[, engine])</p></td>
<td><p>Boolean intersection between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert</span></code>()</p></td>
<td><p>Invert the mesh in- place by reversing the winding of every face and negating normals without dumping the cache.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">md5</span></code>()</p></td>
<td><p>An MD5 of the core geometry information for the mesh, faces and vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_vertices</span></code>([digits, textured])</p></td>
<td><p>If a mesh has vertices that are closer than trimesh.constants.tol.merge reindex faces to reference the same index for both vertices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([face_ids])</p></td>
<td><p>Given a list of face indexes find the outline of those faces and return it as a Path3D.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">process</span></code>()</p></td>
<td><p>Do the bare minimum processing to make a mesh useful.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">register</span></code>(other, **kwargs)</p></td>
<td><p>Align a mesh with another mesh or a PointCloud using the principal axes of inertia as a starting point which is refined by iterative closest point.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_degenerate_faces</span></code>([height])</p></td>
<td><p>Remove degenerate faces (faces without 3 unique vertex indices) from the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_duplicate_faces</span></code>()</p></td>
<td><p>On the current mesh remove any faces which are duplicates.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_infinite_values</span></code>()</p></td>
<td><p>Ensure that every vertex and face consists of finite numbers.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unreferenced_vertices</span></code>()</p></td>
<td><p>Remove all vertices in the current mesh which are not referenced by a face.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rezero</span></code>()</p></td>
<td><p>Translate the mesh so that all vertex vertices are positive.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(count[, return_index])</p></td>
<td><p>Return random samples distributed normally across the surface of the mesh</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scene</span></code>(**kwargs)</p></td>
<td><p>Get a Scene object containing the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section</span></code>(plane_normal, plane_origin)</p></td>
<td><p>Returns a 3D cross section of the current mesh and a plane defined by origin and normal.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">section_multiplane</span></code>(plane_origin, …)</p></td>
<td><p>Return multiple parallel cross sections of the current mesh in 2D.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>(**kwargs)</p></td>
<td><p>Render the mesh in an opengl window.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_plane</span></code>(plane_origin, plane_normal, **kwargs)</p></td>
<td><p>Returns another mesh that is the current mesh sliced by the plane defined by origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoothed</span></code>(**kwargs)</p></td>
<td><p>Return a version of the current mesh which will render nicely, without changing source mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(**kwargs)</p></td>
<td><p>Returns a list of Trimesh objects, based on face connectivity.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>([face_index])</p></td>
<td><p>Subdivide a mesh, with each subdivided face replaced with four smaller faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">submesh</span></code>(faces_sequence, **kwargs)</p></td>
<td><p>Return a subset of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code>()</p></td>
<td><p>Return a dictionary representation of the current mesh, with keys that can be used as the kwargs for the Trimesh constructor, eg:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_mesh</span></code>()</p></td>
<td><p>Return a copy of the Primitive object as a Trimesh object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">union</span></code>(other[, engine])</p></td>
<td><p>Boolean union between this mesh and n other meshes</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unmerge_vertices</span></code>()</p></td>
<td><p>Removes all face references so that every face contains three unique vertex indices and no faces are adjacent.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_faces</span></code>(mask)</p></td>
<td><p>In many cases, we will want to remove specific faces.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_vertices</span></code>(mask[, inverse])</p></td>
<td><p>Update vertices with a mask.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">voxelized</span></code>(pitch, **kwargs)</p></td>
<td><p>Return a Voxel object representing the current mesh discretized into voxels at the specified pitch</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.primitives.Sphere.apply_transform">
<code class="descname">apply_transform</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.primitives.Sphere.apply_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transform to the sphere primitive</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: (4,4) float, homogenous transformation</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.area">
<code class="descname">area</code><a class="headerlink" href="#trimesh.primitives.Sphere.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Surface area of the current sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>area: float, surface area of the sphere Primitive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.bounding_box_oriented">
<code class="descname">bounding_box_oriented</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounding_box_oriented" title="Permalink to this definition">¶</a></dt>
<dd><p>An oriented bounding box for the current mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obb</strong><span class="classifier">trimesh.primitives.Box</span></dt><dd><p>Box object with transform and extents defined
representing the minimum volume oriented bounding box of the mesh</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#trimesh.primitives.Sphere.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The axis aligned bounds of the faces of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">(2, 3) float</span></dt><dd><p>Bounding box with [min, max] coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.moment_inertia">
<code class="descname">moment_inertia</code><a class="headerlink" href="#trimesh.primitives.Sphere.moment_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>The analytic inertia tensor of the sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor: (3,3) float, 3D inertia tensor</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.primitives.Sphere.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.primitives.Sphere.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the current sphere primitive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume: float, volume of the sphere Primitive</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.proximity">
<span id="trimesh-proximity-module"></span><h2>trimesh.proximity module<a class="headerlink" href="#module-trimesh.proximity" title="Permalink to this headline">¶</a></h2>
<div class="section" id="proximity-py">
<h3>proximity.py<a class="headerlink" href="#proximity-py" title="Permalink to this headline">¶</a></h3>
<p>Query mesh- point proximity.</p>
<dl class="class">
<dt id="trimesh.proximity.ProximityQuery">
<em class="property">class </em><code class="descclassname">trimesh.proximity.</code><code class="descname">ProximityQuery</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Proximity queries for the current mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.proximity.ProximityQuery.on_surface" title="trimesh.proximity.ProximityQuery.on_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">on_surface</span></code></a>(**kwargs)</p></td>
<td><p>Given list of points, for each point find the closest point on any triangle of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.proximity.ProximityQuery.signed_distance" title="trimesh.proximity.ProximityQuery.signed_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signed_distance</span></code></a>(points)</p></td>
<td><p>Find the signed distance from a mesh to a list of points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.proximity.ProximityQuery.vertex" title="trimesh.proximity.ProximityQuery.vertex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex</span></code></a>(points)</p></td>
<td><p>Given a set of points, return the closest vertex index to each point</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.on_surface">
<code class="descname">on_surface</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.on_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Given list of points, for each point find the closest point
on any triangle of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(m,3) float, points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closest</strong><span class="classifier">(m,3) float, closest point on triangles for each point</span></dt><dd></dd>
<dt><strong>distance</strong><span class="classifier">(m,)  float, distance</span></dt><dd></dd>
<dt><strong>triangle_id</strong><span class="classifier">(m,)  int, index of closest triangle for each point</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.signed_distance">
<code class="descname">signed_distance</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li><p>Points OUTSIDE the mesh will have NEGATIVE distance</p></li>
<li><p>Points within tol.merge of the surface will have POSITIVE distance</p></li>
<li><p>Points INSIDE the mesh will have POSITIVE distance</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>signed_distance</strong><span class="classifier">(n,3) float, signed distance from point to mesh</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.proximity.ProximityQuery.vertex">
<code class="descname">vertex</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.ProximityQuery.vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of points, return the closest vertex index to each point</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">(n,) float, distance from source point to vertex</span></dt><dd></dd>
<dt><strong>vertex_id</strong><span class="classifier">(n,) int, index of mesh.vertices which is closest</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point">
<code class="descclassname">trimesh.proximity.</code><code class="descname">closest_point</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points, find the closest point on any triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
<dt><strong>points</strong><span class="classifier">(m,3)   float, points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closest</strong><span class="classifier">(m,3) float, closest point on triangles for each point</span></dt><dd></dd>
<dt><strong>distance</strong><span class="classifier">(m,)  float, distance</span></dt><dd></dd>
<dt><strong>triangle_id</strong><span class="classifier">(m,)  int, index of triangle containing closest point</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.closest_point_naive">
<code class="descclassname">trimesh.proximity.</code><code class="descname">closest_point_naive</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.closest_point_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mesh and a list of points find the closest point
on any triangle.</p>
<p>Does this by constructing a very large intermediate array and
comparing every point to every triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Takes mesh to have same interfaces as <cite>closest_point</cite></p>
</dd>
<dt><strong>points</strong><span class="classifier">(m, 3) float</span></dt><dd><p>Points in space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closest</strong><span class="classifier">(m, 3) float</span></dt><dd><p>Closest point on triangles for each point</p>
</dd>
<dt><strong>distance</strong><span class="classifier">(m,) float</span></dt><dd><p>Distances between point and triangle</p>
</dd>
<dt><strong>triangle_id</strong><span class="classifier">(m,) int</span></dt><dd><p>Index of triangle containing closest point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.longest_ray">
<code class="descclassname">trimesh.proximity.</code><code class="descname">longest_ray</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>directions</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.longest_ray" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the lengths of the longest rays which do not intersect the mesh
cast from a list of points in the provided directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>directions</strong><span class="classifier">(n,3) float, directions of rays</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>signed_distance</strong><span class="classifier">(n,) float, length of rays</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.max_tangent_sphere">
<code class="descclassname">trimesh.proximity.</code><code class="descname">max_tangent_sphere</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>inwards=True</em>, <em>normals=None</em>, <em>threshold=1e-06</em>, <em>max_iter=100</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.max_tangent_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the center and radius of the sphere which is tangent to
the mesh at the given point and at least one more point with no
non-tangential intersections with the mesh.</p>
<p>Masatomo Inui, Nobuyuki Umezu &amp; Ryohei Shimane (2016)
Shrinking sphere:
A parallel algorithm for computing the thickness of 3D objects,
Computer-Aided Design and Applications, 13:2, 199-207,
DOI: 10.1080/16864360.2015.1084186</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>inwards</strong><span class="classifier">bool, whether to have the sphere inside or outside the mesh</span></dt><dd></dd>
<dt><strong>normals</strong><span class="classifier">(n,3) float, normals of the mesh at the given points</span></dt><dd><p>None, compute this automatically.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>centers</strong><span class="classifier">(n,3) float, centers of spheres</span></dt><dd></dd>
<dt><strong>radii</strong><span class="classifier">(n,) float, radii of spheres</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.nearby_faces">
<code class="descclassname">trimesh.proximity.</code><code class="descname">nearby_faces</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.nearby_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point find nearby faces relatively quickly.</p>
<p>The closest point on the mesh to the queried point is guaranteed to be
on one of the faces listed.</p>
<p>Does this by finding the nearest vertex on the mesh to each point, and
then returns all the faces that intersect the axis aligned bounding box
centered at the queried point and extending to the nearest vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
<dt><strong>points</strong><span class="classifier">(n,3) float , points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>candidates</strong><span class="classifier">(points,) int, sequence of indexes for mesh.faces</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.signed_distance">
<code class="descclassname">trimesh.proximity.</code><code class="descname">signed_distance</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.signed_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the signed distance from a mesh to a list of points.</p>
<ul class="simple">
<li><p>Points OUTSIDE the mesh will have NEGATIVE distance</p></li>
<li><p>Points within tol.merge of the surface will have POSITIVE distance</p></li>
<li><p>Points INSIDE the mesh will have POSITIVE distance</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>signed_distance</strong><span class="classifier">(n,3) float, signed distance from point to mesh</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.proximity.thickness">
<code class="descclassname">trimesh.proximity.</code><code class="descname">thickness</code><span class="sig-paren">(</span><em>mesh</em>, <em>points</em>, <em>exterior=False</em>, <em>normals=None</em>, <em>method='max_sphere'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.proximity.thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the thickness of the mesh at the given points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n,3) float, list of points in space</span></dt><dd></dd>
<dt><strong>exterior</strong><span class="classifier">bool, whether to compute the exterior thickness</span></dt><dd><p>(a.k.a. reach)</p>
</dd>
<dt><strong>normals</strong><span class="classifier">(n,3) float, normals of the mesh at the given points</span></dt><dd><p>None, compute this automatically.</p>
</dd>
<dt><strong>method</strong><span class="classifier">string, one of ‘max_sphere’ or ‘ray’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>thickness</strong><span class="classifier">(n,) float, thickness</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.registration">
<span id="trimesh-registration-module"></span><h2>trimesh.registration module<a class="headerlink" href="#module-trimesh.registration" title="Permalink to this headline">¶</a></h2>
<div class="section" id="registration-py">
<h3>registration.py<a class="headerlink" href="#registration-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for registering (aligning) point clouds with meshes.</p>
<dl class="function">
<dt id="trimesh.registration.icp">
<code class="descclassname">trimesh.registration.</code><code class="descname">icp</code><span class="sig-paren">(</span><em>a, b, initial=array([[1., 0., 0., 0.],        [0., 1., 0., 0.],        [0., 0., 1., 0.],        [0., 0., 0., 1.]]), threshold=1e-05, max_iterations=20, **kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.icp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the iterative closest point algorithm to align a point cloud with
another point cloud or mesh. Will only produce reasonable results if the
initial transformation is roughly correct. Initial transformation can be
found by applying Procrustes’ analysis to a suitable set of landmark
points (often picked manually).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(n,3) float</span></dt><dd><p>List of points in space.</p>
</dd>
<dt><strong>b</strong><span class="classifier">(m,3) float or Trimesh</span></dt><dd><p>List of points in space or mesh.</p>
</dd>
<dt><strong>initial</strong><span class="classifier">(4,4) float</span></dt><dd><p>Initial transformation.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Stop when change in cost is less than threshold</p>
</dd>
<dt><strong>max_iterations</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Args to pass to procrustes</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(4,4) float</span></dt><dd><p>The transformation matrix sending a to b</p>
</dd>
<dt><strong>transformed</strong><span class="classifier">(n,3) float</span></dt><dd><p>The image of a under the transformation</p>
</dd>
<dt><strong>cost</strong><span class="classifier">float</span></dt><dd><p>The cost of the transformation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.mesh_other">
<code class="descclassname">trimesh.registration.</code><code class="descname">mesh_other</code><span class="sig-paren">(</span><em>mesh</em>, <em>other</em>, <em>samples=500</em>, <em>scale=False</em>, <em>icp_first=10</em>, <em>icp_final=50</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.mesh_other" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a mesh with another mesh or a PointCloud using
the principal axes of inertia as a starting point which
is refined by iterative closest point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh object</span></dt><dd><p>Mesh to align with other</p>
</dd>
<dt><strong>other</strong><span class="classifier">trimesh.Trimesh or (n, 3) float</span></dt><dd><p>Mesh or points in space</p>
</dd>
<dt><strong>samples</strong><span class="classifier">int</span></dt><dd><p>Number of samples from mesh surface to align</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool</span></dt><dd><p>Allow scaling in transform</p>
</dd>
<dt><strong>icp_first</strong><span class="classifier">int</span></dt><dd><p>How many ICP iterations for the 9 possible
combinations of sign flippage</p>
</dd>
<dt><strong>icp_final</strong><span class="classifier">int</span></dt><dd><p>How many ICP iterations for the closest
candidate from the wider search</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh_to_other</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transform to align mesh to the other object</p>
</dd>
<dt><strong>cost</strong><span class="classifier">float</span></dt><dd><p>Average squared distance per point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.registration.procrustes">
<code class="descclassname">trimesh.registration.</code><code class="descname">procrustes</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>reflection=True</em>, <em>translation=True</em>, <em>scale=True</em>, <em>return_cost=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.registration.procrustes" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Procrustes’ analysis subject to constraints. Finds the
transformation T mapping a to b which minimizes the square sum
distances between Ta and b, also called the cost.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(n,3) float</span></dt><dd><p>List of points in space</p>
</dd>
<dt><strong>b</strong><span class="classifier">(n,3) float</span></dt><dd><p>List of points in space</p>
</dd>
<dt><strong>reflection</strong><span class="classifier">bool</span></dt><dd><p>If the transformation is allowed reflections</p>
</dd>
<dt><strong>translation</strong><span class="classifier">bool</span></dt><dd><p>If the transformation is allowed translations</p>
</dd>
<dt><strong>scale</strong><span class="classifier">bool</span></dt><dd><p>If the transformation is allowed scaling</p>
</dd>
<dt><strong>return_cost</strong><span class="classifier">bool</span></dt><dd><p>Whether to return the cost and transformed a as well</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(4,4) float</span></dt><dd><p>The transformation matrix sending a to b</p>
</dd>
<dt><strong>transformed</strong><span class="classifier">(n,3) float</span></dt><dd><p>The image of a under the transformation</p>
</dd>
<dt><strong>cost</strong><span class="classifier">float</span></dt><dd><p>The cost of the transformation</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.remesh">
<span id="trimesh-remesh-module"></span><h2>trimesh.remesh module<a class="headerlink" href="#module-trimesh.remesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="remesh-py">
<h3>remesh.py<a class="headerlink" href="#remesh-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with re- triangulation of existing meshes.</p>
<dl class="function">
<dt id="trimesh.remesh.subdivide">
<code class="descclassname">trimesh.remesh.</code><code class="descname">subdivide</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>face_index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh into smaller triangles.</p>
<p>Note that if <cite>face_index</cite> is passed, only those faces will
be subdivided and their neighbors won’t be modified making
the mesh no longer “watertight.”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Vertices in space</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(n, 3) int</span></dt><dd><p>Indexes of vertices which make up triangular faces</p>
</dd>
<dt><strong>face_index</strong><span class="classifier">faces to subdivide.</span></dt><dd><p>if None: all faces of mesh will be subdivided
if (n,) int array of indices: only specified faces</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>new_vertices</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Vertices in space</p>
</dd>
<dt><strong>new_faces</strong><span class="classifier">(n, 3) int</span></dt><dd><p>Remeshed faces</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.remesh.subdivide_to_size">
<code class="descclassname">trimesh.remesh.</code><code class="descname">subdivide_to_size</code><span class="sig-paren">(</span><em>vertices</em>, <em>faces</em>, <em>max_edge</em>, <em>max_iter=10</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.remesh.subdivide_to_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide a mesh until every edge is shorter than a
specified length.</p>
<p>Will return a triangle soup, not a nicely structured mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Vertices in space</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(m, 3) int</span></dt><dd><p>Indices of vertices which make up triangles</p>
</dd>
<dt><strong>max_edge</strong><span class="classifier">float</span></dt><dd><p>Maximum length of any edge in the result</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of times to run subdivision</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(j, 3) float</span></dt><dd><p>Vertices in space</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(q, 3) int</span></dt><dd><p>Indices of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.rendering">
<span id="trimesh-rendering-module"></span><h2>trimesh.rendering module<a class="headerlink" href="#module-trimesh.rendering" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rendering-py">
<h3>rendering.py<a class="headerlink" href="#rendering-py" title="Permalink to this headline">¶</a></h3>
<p>Functions to convert trimesh objects to pyglet/opengl objects.</p>
<dl class="function">
<dt id="trimesh.rendering.colors_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">colors_to_gl</code><span class="sig-paren">(</span><em>colors</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.colors_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of colors (or None) return a GL- acceptable list of colors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>colors: (count, (3 or 4)) float</strong></dt><dd><p>Input colors as an array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>colors_type</strong><span class="classifier">str</span></dt><dd><p>Color type</p>
</dd>
<dt><strong>colors_gl</strong><span class="classifier">(count,) list</span></dt><dd><p>Colors to pass to pyglet</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.convert_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">convert_to_vertexlist</code><span class="sig-paren">(</span><em>geometry</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.convert_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to convert various geometry objects to the constructor
args for a pyglet indexed vertex list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">Trimesh, Path2D, Path3D, (n,2) float, (n,3) float</span></dt><dd><p>Object to render</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>args</strong><span class="classifier">tuple</span></dt><dd><p>Args to be passed to pyglet indexed vertex list
constructor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.light_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">light_to_gl</code><span class="sig-paren">(</span><em>light</em>, <em>transform</em>, <em>lightN</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.light_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert trimesh.scene.lighting.Light objects into
args for gl.glLightFv calls</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>light</strong><span class="classifier">trimesh.scene.lighting.Light</span></dt><dd><p>Light object to be converted to GL</p>
</dd>
<dt><strong>transform</strong><span class="classifier">(4, 4) float</span></dt><dd><p>Transformation matrix of light</p>
</dd>
<dt><strong>lightN</strong><span class="classifier">int</span></dt><dd><p>Result of gl.GL_LIGHT0, gl.GL_LIGHT1, etc</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>multiarg</strong><span class="classifier">[tuple]</span></dt><dd><p>List of args to pass to gl.glLightFv eg:
[gl.glLightfb(<a href="#id9"><span class="problematic" id="id10">*</span></a>a) for a in multiarg]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.material_to_texture">
<code class="descclassname">trimesh.rendering.</code><code class="descname">material_to_texture</code><span class="sig-paren">(</span><em>material</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.material_to_texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a trimesh.visual.texture.Material object into
a pyglet- compatible texture object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>material</strong><span class="classifier">trimesh.visual.texture.Material</span></dt><dd><p>Material to be converted</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>texture</strong><span class="classifier">pyglet.image.Texture</span></dt><dd><p>Texture loaded into pyglet form</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.matrix_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">matrix_to_gl</code><span class="sig-paren">(</span><em>matrix</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.matrix_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy row- major homogenous transformation matrix
to a flat column- major GLfloat transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(4,4) float</span></dt><dd><p>Row- major homogenous transform</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>glmatrix</strong><span class="classifier">(16,) gl.GLfloat</span></dt><dd><p>Transform in pyglet format</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.mesh_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">mesh_to_vertexlist</code><span class="sig-paren">(</span><em>mesh</em>, <em>group=None</em>, <em>smooth=True</em>, <em>smooth_threshold=60000</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.mesh_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Trimesh object to arguments for an
indexed vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh to be rendered</p>
</dd>
<dt><strong>group</strong><span class="classifier">str</span></dt><dd><p>Rendering group for the vertex list</p>
</dd>
<dt><strong>smooth</strong><span class="classifier">bool</span></dt><dd><p>Should we try to smooth shade the mesh</p>
</dd>
<dt><strong>smooth_threshold</strong><span class="classifier">int</span></dt><dd><p>Maximum number of faces to smooth shade</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>args</strong><span class="classifier">(7,) tuple</span></dt><dd><p>Args for vertex list constructor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.path_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">path_to_vertexlist</code><span class="sig-paren">(</span><em>path</em>, <em>group=None</em>, <em>colors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.path_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a Path3D object to arguments for an
indexed vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">trimesh.path.Path3D object</span></dt><dd><p>Mesh to be rendered</p>
</dd>
<dt><strong>group</strong><span class="classifier">str</span></dt><dd><p>Rendering group for the vertex list</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>args</strong><span class="classifier">(7,) tuple</span></dt><dd><p>Args for vertex list constructor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.points_to_vertexlist">
<code class="descclassname">trimesh.rendering.</code><code class="descname">points_to_vertexlist</code><span class="sig-paren">(</span><em>points</em>, <em>colors=None</em>, <em>group=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.points_to_vertexlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a numpy array of 3D points to args for
a vertex list constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points to be rendered</p>
</dd>
<dt><strong>colors</strong><span class="classifier">(n, 3) or (n, 4) float</span></dt><dd><p>Colors for each point</p>
</dd>
<dt><strong>group</strong><span class="classifier">str</span></dt><dd><p>Rendering group for the vertex list</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>args</strong><span class="classifier">(7,) tuple</span></dt><dd><p>Args for vertex list constructor</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.rendering.vector_to_gl">
<code class="descclassname">trimesh.rendering.</code><code class="descname">vector_to_gl</code><span class="sig-paren">(</span><em>array</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.rendering.vector_to_gl" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array and an optional set of args into a
flat vector of gl.GLfloat</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.repair">
<span id="trimesh-repair-module"></span><h2>trimesh.repair module<a class="headerlink" href="#module-trimesh.repair" title="Permalink to this headline">¶</a></h2>
<div class="section" id="repair-py">
<h3>repair.py<a class="headerlink" href="#repair-py" title="Permalink to this headline">¶</a></h3>
<p>Fill holes and fix winding and normals of meshes.</p>
<dl class="function">
<dt id="trimesh.repair.broken_faces">
<code class="descclassname">trimesh.repair.</code><code class="descname">broken_faces</code><span class="sig-paren">(</span><em>mesh</em>, <em>color=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.broken_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of faces in the mesh which break the
watertight status of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
<dt><strong>color: (4,) uint8, will set broken faces to this color</strong></dt><dd><p>None,       will not alter mesh colors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>broken: (n, ) int, indexes of mesh.faces</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fill_holes">
<code class="descclassname">trimesh.repair.</code><code class="descname">fill_holes</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill single- triangle holes on triangular meshes by adding
new triangles to fill the holes. New triangles will have
proper winding and normals, and if face colors exist the color
of the last face will be assigned to the new triangles.</p>
<dl class="simple">
<dt>mesh<span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh will be repaired in- place</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_inversion">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_inversion</code><span class="sig-paren">(</span><em>mesh</em>, <em>multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_inversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a mesh has normals pointing “out.”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:      Trimesh object</strong></dt><dd></dd>
<dt><strong>multibody: bool, if True will try to fix normals on every body</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_normals">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_normals</code><span class="sig-paren">(</span><em>mesh</em>, <em>multibody=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the winding and direction of a mesh face and
face normals in-place.</p>
<p>Really only meaningful on watertight meshes, but will orient all
faces and winding in a uniform way for non-watertight face
patches as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh:      Trimesh object</strong></dt><dd></dd>
<dt><strong>multibody: bool, if True try to correct normals direction</strong></dt><dd><p>on every body.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.repair.fix_winding">
<code class="descclassname">trimesh.repair.</code><code class="descname">fix_winding</code><span class="sig-paren">(</span><em>mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.repair.fix_winding" title="Permalink to this definition">¶</a></dt>
<dd><p>Traverse and change mesh faces in-place to make sure winding
is correct, with edges on adjacent faces in
opposite directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.sample">
<span id="trimesh-sample-module"></span><h2>trimesh.sample module<a class="headerlink" href="#module-trimesh.sample" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sample-py">
<h3>sample.py<a class="headerlink" href="#sample-py" title="Permalink to this headline">¶</a></h3>
<p>Randomly sample surface and volume of meshes.</p>
<dl class="function">
<dt id="trimesh.sample.sample_surface">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning the specified
number of points</p>
<p>For individual triangle sampling uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/TrianglePointPicking.html">http://mathworld.wolfram.com/TrianglePointPicking.html</a></p>
<p>mesh: Trimesh object
count: number of points to return</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples: (count,3) points in space on the surface of mesh</strong></dt><dd></dd>
<dt><strong>face_index: (count,) indices of faces for each sampled point</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_even">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface_even</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_even" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the surface of a mesh, returning samples which are
approximately evenly spaced.</p>
<p>mesh: Trimesh object
count: number of points to return</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>samples: (count,3) points in space on the surface of mesh</strong></dt><dd></dd>
<dt><strong>face_index: (count,) indices of faces for each sampled point</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.sample_surface_sphere">
<code class="descclassname">trimesh.sample.</code><code class="descname">sample_surface_sphere</code><span class="sig-paren">(</span><em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.sample_surface_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Correctly pick random points on the surface of a unit sphere</p>
<p>Uses this method:
<a class="reference external" href="http://mathworld.wolfram.com/SpherePointPicking.html">http://mathworld.wolfram.com/SpherePointPicking.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>count: int, number of points to return</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points: (count,3) float, list of random points on a unit sphere</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_mesh">
<code class="descclassname">trimesh.sample.</code><code class="descname">volume_mesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Use rejection sampling to produce points randomly distributed
in the volume of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object</strong></dt><dd></dd>
<dt><strong>count: int, number of samples desired</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples: (n,3) float, points in the volume of the mesh.</strong></dt><dd><p>where: n &lt;= count</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.sample.volume_rectangular">
<code class="descclassname">trimesh.sample.</code><code class="descname">volume_rectangular</code><span class="sig-paren">(</span><em>extents</em>, <em>count</em>, <em>transform=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.sample.volume_rectangular" title="Permalink to this definition">¶</a></dt>
<dd><p>Return random samples inside a rectangular volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>extents:   (3,) float, side lengths of rectangular solid</strong></dt><dd></dd>
<dt><strong>count:     int, number of points to return</strong></dt><dd></dd>
<dt><strong>transform: (4,4) float, transformation matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>samples: (count, 3) float, points in volume</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.smoothing">
<span id="trimesh-smoothing-module"></span><h2>trimesh.smoothing module<a class="headerlink" href="#module-trimesh.smoothing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="trimesh.smoothing.filter_humphrey">
<code class="descclassname">trimesh.smoothing.</code><code class="descname">filter_humphrey</code><span class="sig-paren">(</span><em>mesh</em>, <em>alpha=0.1</em>, <em>beta=0.5</em>, <em>iterations=10</em>, <em>laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_humphrey" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing
and Humphrey filtering.</p>
<p>Articles
“Improved Laplacian Smoothing of Noisy Surface Meshes”
J. Vollmer, R. Mencl, and H. Muller</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh to be smoothed in place</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Controls shrinkage, range is 0.0 - 1.0
If 0.0, not considered
If 1.0, no smoothing</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float</span></dt><dd><p>Controls how aggressive smoothing is
If 0.0, no smoothing
If 1.0, full aggressiveness</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">int</span></dt><dd><p>Number of passes to run filter</p>
</dd>
<dt><strong>laplacian_operator</strong><span class="classifier">None or scipy.sparse.coo.coo_matrix</span></dt><dd><p>Sparse matrix laplacian operator
Will be autogenerated if None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.filter_laplacian">
<code class="descclassname">trimesh.smoothing.</code><code class="descname">filter_laplacian</code><span class="sig-paren">(</span><em>mesh</em>, <em>lamb=0.5</em>, <em>iterations=10</em>, <em>laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing.</p>
<p>Articles
“Improved Laplacian Smoothing of Noisy Surface Meshes”
J. Vollmer, R. Mencl, and H. Muller</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh to be smoothed in place</p>
</dd>
<dt><strong>lamb</strong><span class="classifier">float</span></dt><dd><p>Diffusion speed constant
If 0.0, no diffusion
If 1.0, full diffusion</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">int</span></dt><dd><p>Number of passes to run filter</p>
</dd>
<dt><strong>laplacian_operator</strong><span class="classifier">None or scipy.sparse.coo.coo_matrix</span></dt><dd><p>Sparse matrix laplacian operator
Will be autogenerated if None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.filter_taubin">
<code class="descclassname">trimesh.smoothing.</code><code class="descname">filter_taubin</code><span class="sig-paren">(</span><em>mesh</em>, <em>lamb=0.5</em>, <em>nu=0.5</em>, <em>iterations=10</em>, <em>laplacian_operator=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.filter_taubin" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a mesh in-place using laplacian smoothing
and taubin filtering.</p>
<p>Articles
“Improved Laplacian Smoothing of Noisy Surface Meshes”
J. Vollmer, R. Mencl, and H. Muller</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Mesh to be smoothed in place.</p>
</dd>
<dt><strong>lamb</strong><span class="classifier">float</span></dt><dd><p>Controls shrinkage, range is 0.0 - 1.0</p>
</dd>
<dt><strong>nu</strong><span class="classifier">float</span></dt><dd><p>Controls dilation, range is 0.0 - 1.0
Nu shall be between 0.0 &lt; 1.0/lambda - 1.0/nu &lt; 0.1</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">int</span></dt><dd><p>Number of passes to run the filter</p>
</dd>
<dt><strong>laplacian_operator</strong><span class="classifier">None or scipy.sparse.coo.coo_matrix</span></dt><dd><p>Sparse matrix laplacian operator
Will be autogenerated if None</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.smoothing.laplacian_calculation">
<code class="descclassname">trimesh.smoothing.</code><code class="descname">laplacian_calculation</code><span class="sig-paren">(</span><em>mesh</em>, <em>equal_weight=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.smoothing.laplacian_calculation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a sparse matrix for laplacian operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Input geometry</p>
</dd>
<dt><strong>equal_weight</strong><span class="classifier">bool</span></dt><dd><p>If True, all neighbors will be considered equally
If False, all neightbors will be weighted by inverse distance</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>laplacian</strong><span class="classifier">scipy.sparse.coo.coo_matrix</span></dt><dd><p>Laplacian operator</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-trimesh.transformations">
<span id="trimesh-transformations-module"></span><h2>trimesh.transformations module<a class="headerlink" href="#module-trimesh.transformations" title="Permalink to this headline">¶</a></h2>
<p>Homogeneous Transformation Matrices and Quaternions.</p>
<p>A library for calculating 4x4 matrices for translating, rotating, reflecting,
scaling, shearing, projecting, orthogonalizing, and superimposing arrays of
3D homogeneous coordinates as well as for converting between rotation matrices,
Euler angles, and quaternions. Also includes an Arcball control object and
functions to decompose transformation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Christoph Gohlke</a></p>
</dd>
<dt class="field-even">Organization</dt>
<dd class="field-even"><p>Laboratory for Fluorescence Dynamics, University of California, Irvine</p>
</dd>
<dt class="field-odd">Version</dt>
<dd class="field-odd"><p>2017.02.17</p>
</dd>
</dl>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="http://www.python.org">CPython 2.7 or 3.4</a></p></li>
<li><p><a class="reference external" href="http://www.np.org">numpy 1.9</a></p></li>
<li><p><a class="reference external" href="http://www.lfd.uci.edu/~gohlke/">Transformations.c 2015.03.19</a>
(recommended for speedup of some functions)</p></li>
</ul>
</div>
<div class="section" id="notes">
<h3>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h3>
<p>The API is not stable yet and is expected to change between revisions.</p>
<p>This Python code is not optimized for speed. Refer to the transformations.c
module for a faster implementation of some functions.</p>
<p>Documentation in HTML format can be generated with epydoc.</p>
<p>Matrices (M) can be inverted using np.linalg.inv(M), be concatenated using
np.dot(M0, M1), or transform homogeneous coordinate arrays (v) using
np.dot(M, v) for shape (4, *) column vectors, respectively
np.dot(v, M.T) for shape (*, 4) row vectors (“array of points”).</p>
<p>This module follows the “column vectors on the right” and “row major storage”
(C contiguous) conventions. The translation components are in the right column
of the transformation matrix, i.e. M[:3, 3].
The transpose of the transformation matrices may have to be used to interface
with other graphics systems, e.g. with OpenGL’s glMultMatrixd(). See also [16].</p>
<p>Calculations are carried out with np.float64 precision.</p>
<p>Vector, point, quaternion, and matrix function arguments are expected to be
“array like”, i.e. tuple, list, or numpy arrays.</p>
<p>Return types are numpy arrays unless specified otherwise.</p>
<p>Angles are in radians unless specified otherwise.</p>
<p>Quaternions w+ix+jy+kz are represented as [w, x, y, z].</p>
<p>A triple of Euler angles can be applied/interpreted in 24 ways, which can
be specified using a 4 character string or encoded 4-tuple:</p>
<blockquote>
<div><p><em>Axes 4-string</em>: e.g. ‘sxyz’ or ‘ryxy’</p>
<ul class="simple">
<li><p>first character : rotations are applied to ‘s’tatic or ‘r’otating frame</p></li>
<li><p>remaining characters : successive rotation axis ‘x’, ‘y’, or ‘z’</p></li>
</ul>
<p><em>Axes 4-tuple</em>: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)</p>
<ul class="simple">
<li><p>inner axis: code of axis (‘x’:0, ‘y’:1, ‘z’:2) of rightmost matrix.</p></li>
<li><p>parity : even (0) if inner axis ‘x’ is followed by ‘y’, ‘y’ is followed
by ‘z’, or ‘z’ is followed by ‘x’. Otherwise odd (1).</p></li>
<li><p>repetition : first and last axis are same (1) or different (0).</p></li>
<li><p>frame : rotations are applied to static (0) or rotating (1) frame.</p></li>
</ul>
</div></blockquote>
<p>Other Python packages and modules for 3D transformations and quaternions:</p>
<ul class="simple">
<li><dl class="simple">
<dt><a class="reference external" href="https://pypi.python.org/pypi/transforms3d">Transforms3d</a></dt><dd><p>includes most code of this module.</p>
</dd>
</dl>
</li>
<li><p><a class="reference external" href="http://www.blender.org/api/blender_python_api">Blender.mathutils</a></p></li>
<li><p><a class="reference external" href="https://github.com/numpy/numpy-dtypes">numpy-dtypes</a></p></li>
</ul>
</div>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Matrices and transformations. Ronald Goldman.
In “Graphics Gems I”, pp 472-475. Morgan Kaufmann, 1990.</p></li>
<li><p>More matrices and transformations: shear and pseudo-perspective.
Ronald Goldman. In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</p></li>
<li><p>Decomposing a matrix into simple transformations. Spencer Thomas.
In “Graphics Gems II”, pp 320-323. Morgan Kaufmann, 1991.</p></li>
<li><p>Recovering the data from the transformation matrix. Ronald Goldman.
In “Graphics Gems II”, pp 324-331. Morgan Kaufmann, 1991.</p></li>
<li><p>Euler angle conversion. Ken Shoemake.
In “Graphics Gems IV”, pp 222-229. Morgan Kaufmann, 1994.</p></li>
<li><p>Arcball rotation control. Ken Shoemake.
In “Graphics Gems IV”, pp 175-192. Morgan Kaufmann, 1994.</p></li>
<li><p>Representing attitude: Euler angles, unit quaternions, and rotation
vectors. James Diebel. 2006.</p></li>
<li><p>A discussion of the solution for the best rotation to relate two sets
of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.</p></li>
<li><p>Closed-form solution of absolute orientation using unit quaternions.
BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.</p></li>
<li><p>Quaternions. Ken Shoemake.
<a class="reference external" href="http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf">http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf</a></p></li>
<li><p>From quaternion to matrix and back. JMP van Waveren. 2005.
<a class="reference external" href="http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm">http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm</a></p></li>
<li><p>Uniform random rotations. Ken Shoemake.
In “Graphics Gems III”, pp 124-132. Morgan Kaufmann, 1992.</p></li>
<li><p>Quaternion in molecular modeling. CFF Karney.
J Mol Graph Mod, 25(5):595-604</p></li>
<li><p>New method for extracting the quaternion from a rotation matrix.
Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.</p></li>
<li><p>Multiple View Geometry in Computer Vision. Hartley and Zissermann.
Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.</p></li>
<li><p>Column Vectors vs. Row Vectors.
<a class="reference external" href="http://steve.hollasch.net/cgindex/math/matrix/column-vec.html">http://steve.hollasch.net/cgindex/math/matrix/column-vec.html</a></p></li>
</ol>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.123</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.234</span><span class="p">,</span> <span class="mf">2.345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">zaxis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rx</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ry</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rz</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">Rx</span><span class="p">,</span> <span class="n">Ry</span><span class="p">,</span> <span class="n">Rz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">],</span> <span class="n">euler</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Re</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Re</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span> <span class="o">=</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">Re</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">al</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="s1">&#39;rxyz&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qx</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qy</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qz</span> <span class="o">=</span> <span class="n">quaternion_about_axis</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qz</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Rq</span> <span class="o">=</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">Rq</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">scale_matrix</span><span class="p">(</span><span class="mf">1.23</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">translation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span> <span class="o">=</span> <span class="n">shear_matrix</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">xaxis</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">zaxis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">random_rotation_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">concatenate_matrices</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span> <span class="o">=</span> <span class="n">decompose_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.23</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s1">&#39;sxyz&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">angles</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M1</span> <span class="o">=</span> <span class="n">compose_matrix</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">persp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_same_transform</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">random_vector</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="n">vector_product</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">v2</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="module-trimesh.triangles">
<span id="trimesh-triangles-module"></span><h2>trimesh.triangles module<a class="headerlink" href="#module-trimesh.triangles" title="Permalink to this headline">¶</a></h2>
<div class="section" id="triangles-py">
<h3>triangles.py<a class="headerlink" href="#triangles-py" title="Permalink to this headline">¶</a></h3>
<p>Functions for dealing with triangle soups in (n, 3, 3) float form.</p>
<dl class="function">
<dt id="trimesh.triangles.all_coplanar">
<code class="descclassname">trimesh.triangles.</code><code class="descname">all_coplanar</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.all_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if a list of triangles are all coplanar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles: (n, 3, 3) float</strong></dt><dd><p>Vertices of triangles</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>all_coplanar</strong><span class="classifier">bool</span></dt><dd><p>True if all triangles are coplanar</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.angles">
<code class="descclassname">trimesh.triangles.</code><code class="descname">angles</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the angles of input triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Vertex positions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>angles</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Angles at vertex positions, in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.any_coplanar">
<code class="descclassname">trimesh.triangles.</code><code class="descname">any_coplanar</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.any_coplanar" title="Permalink to this definition">¶</a></dt>
<dd><p>For a list of triangles if the FIRST triangle is coplanar
with ANY of the following triangles, return True.
Otherwise, return False.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.area">
<code class="descclassname">trimesh.triangles.</code><code class="descname">area</code><span class="sig-paren">(</span><em>triangles=None</em>, <em>crosses=None</em>, <em>sum=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sum area of input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Vertices of triangles</p>
</dd>
<dt><strong>crosses</strong><span class="classifier">(n, 3) float or None</span></dt><dd><p>As a speedup don’t re- compute cross products</p>
</dd>
<dt><strong>sum</strong><span class="classifier">bool</span></dt><dd><p>Return summed area or individual triangle area</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">(n,) float or float</span></dt><dd><p>Individual or summed area depending on <cite>sum</cite> argument</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.barycentric_to_points">
<code class="descclassname">trimesh.triangles.</code><code class="descname">barycentric_to_points</code><span class="sig-paren">(</span><em>triangles</em>, <em>barycentric</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.barycentric_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of barycentric coordinates on a list of triangles
to cartesian points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles in space</p>
</dd>
<dt><strong>barycentric</strong><span class="classifier">(n, 2) float</span></dt><dd><p>Barycentric coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(m, 3) float</span></dt><dd><p>Points in space</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.bounds_tree">
<code class="descclassname">trimesh.triangles.</code><code class="descname">bounds_tree</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles, create an r-tree for broad- phase
collision detection</p>
<dl class="simple">
<dt>triangles<span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles in space</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">rtree.Rtree</span></dt><dd><p>One node per triangle</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.closest_point">
<code class="descclassname">trimesh.triangles.</code><code class="descname">closest_point</code><span class="sig-paren">(</span><em>triangles</em>, <em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.closest_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest point on the surface of each triangle for a
list of corresponding points.</p>
<p>Implements the method from “Real Time Collision Detection” and
use the same variable names as “ClosestPtPointTriangle” to avoid
being any more confusing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangle vertices in space</p>
</dd>
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closest</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Point on each triangle closest to each point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.cross">
<code class="descclassname">trimesh.triangles.</code><code class="descname">cross</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cross product of two edges from input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles: (n, 3, 3) float</strong></dt><dd><p>Vertices of triangles</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>crosses</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Cross product of two edge vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.extents">
<code class="descclassname">trimesh.triangles.</code><code class="descname">extents</code><span class="sig-paren">(</span><em>triangles</em>, <em>areas=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 2D bounding box size of each triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles in space</p>
</dd>
<dt><strong>areas</strong><span class="classifier">(n,) float</span></dt><dd><p>Optional area of input triangles</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>box</strong><span class="classifier">(n, 2) float</span></dt><dd><p>The size of each triangle’s 2D oriented bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.mass_properties">
<code class="descclassname">trimesh.triangles.</code><code class="descname">mass_properties</code><span class="sig-paren">(</span><em>triangles</em>, <em>crosses=None</em>, <em>density=1.0</em>, <em>center_mass=None</em>, <em>skip_inertia=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.mass_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mass properties of a group of triangles.</p>
<p>Implemented from:
<a class="reference external" href="http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf">http://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangle vertices in space</p>
</dd>
<dt><strong>crosses</strong><span class="classifier">(n,) float</span></dt><dd><p>Optional cross products of triangles</p>
</dd>
<dt><strong>density</strong><span class="classifier">float</span></dt><dd><p>Optional override for density</p>
</dd>
<dt><strong>center_mass</strong><span class="classifier">(3,) float</span></dt><dd><p>Optional override for center mass</p>
</dd>
<dt><strong>skip_inertia</strong><span class="classifier">bool</span></dt><dd><p>if True will not return moments matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>info</strong><span class="classifier">dict</span></dt><dd><p>Mass properties</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.nondegenerate">
<code class="descclassname">trimesh.triangles.</code><code class="descname">nondegenerate</code><span class="sig-paren">(</span><em>triangles</em>, <em>areas=None</em>, <em>height=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.nondegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all triangles which have an oriented bounding box
where both of the two sides is larger than a specified height.</p>
<p>Degenerate triangles can be when:
1) Two of the three vertices are colocated
2) All three vertices are unique but colinear</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles in space</p>
</dd>
<dt><strong>height</strong><span class="classifier">float</span></dt><dd><p>Minimum edge length of a triangle to keep</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nondegenerate</strong><span class="classifier">(n,) bool</span></dt><dd><p>True if a triangle meets required minimum height</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.normals">
<code class="descclassname">trimesh.triangles.</code><code class="descname">normals</code><span class="sig-paren">(</span><em>triangles=None</em>, <em>crosses=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the normals of input triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Vertex positions</p>
</dd>
<dt><strong>crosses</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Cross products of edge vectors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>normals</strong><span class="classifier">(m, 3) float</span></dt><dd><p>Normal vectors</p>
</dd>
<dt><strong>valid</strong><span class="classifier">(n,) bool</span></dt><dd><p>Was the face nonzero area or not</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.points_to_barycentric">
<code class="descclassname">trimesh.triangles.</code><code class="descname">points_to_barycentric</code><span class="sig-paren">(</span><em>triangles</em>, <em>points</em>, <em>method='cramer'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.points_to_barycentric" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the barycentric coordinates of points relative to triangles.</p>
<dl class="simple">
<dt>The Cramer’s rule solution implements:</dt><dd><p><a class="reference external" href="http://blackpawn.com/texts/pointinpoly">http://blackpawn.com/texts/pointinpoly</a></p>
</dd>
<dt>The cross product solution implements:</dt><dd><p><a class="reference external" href="https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf">https://www.cs.ubc.ca/~heidrich/Papers/JGT.05.pdf</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles vertices in space</p>
</dd>
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Point in space associated with a triangle</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><dl class="simple">
<dt>Which method to compute the barycentric coordinates with:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘cross’: uses a method using cross products, roughly 2x slower but</dt><dd><p>different numerical robustness properties</p>
</dd>
</dl>
</li>
<li><p>anything else: uses a cramer’s rule solution</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>barycentric</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Barycentric coordinates of each point</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.to_kwargs">
<code class="descclassname">trimesh.triangles.</code><code class="descname">to_kwargs</code><span class="sig-paren">(</span><em>triangles</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.to_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of triangles to the kwargs for the Trimesh
constructor.</p>
<dl class="simple">
<dt>triangles<span class="classifier">(n, 3, 3) float</span></dt><dd><p>Triangles in space</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments for the trimesh.Trimesh constructor
Includes keys ‘vertices’ and ‘faces’</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="o">**</span><span class="n">trimesh</span><span class="o">.</span><span class="n">triangles</span><span class="o">.</span><span class="n">to_kwargs</span><span class="p">(</span><span class="n">triangles</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="trimesh.triangles.windings_aligned">
<code class="descclassname">trimesh.triangles.</code><code class="descname">windings_aligned</code><span class="sig-paren">(</span><em>triangles</em>, <em>normals_compare</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.triangles.windings_aligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of triangles and a list of normals determine if the
two are aligned</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>triangles</strong><span class="classifier">(n, 3, 3) float</span></dt><dd><p>Vertex locations in space</p>
</dd>
<dt><strong>normals_compare</strong><span class="classifier">(n, 3) float</span></dt><dd><p>List of normals to compare</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>aligned</strong><span class="classifier">(n,) bool</span></dt><dd><p>Are normals aligned with triangles</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.units">
<span id="trimesh-units-module"></span><h2>trimesh.units module<a class="headerlink" href="#module-trimesh.units" title="Permalink to this headline">¶</a></h2>
<div class="section" id="units-py">
<h3>units.py<a class="headerlink" href="#units-py" title="Permalink to this headline">¶</a></h3>
<p>Deal with physical unit systems (i.e. inches, mm)</p>
<p>Very basic conversions, and no requirement for
sympy.physics.units or pint.</p>
<dl class="function">
<dt id="trimesh.units.unit_conversion">
<code class="descclassname">trimesh.units.</code><code class="descname">unit_conversion</code><span class="sig-paren">(</span><em>current</em>, <em>desired</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.unit_conversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the conversion from one set of units to another.</p>
<dl class="simple">
<dt>current<span class="classifier">str</span></dt><dd><p>Unit system values are in now (eg ‘millimeters’)</p>
</dd>
<dt>desired<span class="classifier">str</span></dt><dd><p>Unit system we’d like values in (eg ‘inches’)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>conversion</strong><span class="classifier">float</span></dt><dd><p>Number to multiply by to put values into desired units</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.units.units_from_metadata">
<code class="descclassname">trimesh.units.</code><code class="descname">units_from_metadata</code><span class="sig-paren">(</span><em>obj</em>, <em>guess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.units.units_from_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract hints from metadata and if that fails
guess based on the object scale.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object</strong></dt><dd><p>Has attributes ‘metadata’ (dict) and ‘scale’ (float)</p>
</dd>
<dt><strong>guess</strong><span class="classifier">bool</span></dt><dd><p>If metadata doesn’t indicate units, guess from scale</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>units: str</strong></dt><dd><p>A guess of what the units might be</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.util">
<span id="trimesh-util-module"></span><h2>trimesh.util module<a class="headerlink" href="#module-trimesh.util" title="Permalink to this headline">¶</a></h2>
<div class="section" id="util-py">
<h3>util.py<a class="headerlink" href="#util-py" title="Permalink to this headline">¶</a></h3>
<p>Standalone functions which require only imports from numpy and the
standard library.</p>
<p>Other libraries may be imported must be wrapped in try/except blocks
or imported inside of a function</p>
<dl class="function">
<dt id="trimesh.util.append_faces">
<code class="descclassname">trimesh.util.</code><code class="descname">append_faces</code><span class="sig-paren">(</span><em>vertices_seq</em>, <em>faces_seq</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.append_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of zero- indexed faces and vertices
combine them into a single array of faces and
a single array of vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices_seq</strong><span class="classifier">(n, ) sequence of (m, d) float</span></dt><dd><p>Multiple arrays of verticesvertex arrays</p>
</dd>
<dt><strong>faces_seq</strong><span class="classifier">(n, ) sequence of (p, j) int</span></dt><dd><p>Zero indexed faces for matching vertices</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertices</strong><span class="classifier">(i, d) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(j, 3) int</span></dt><dd><p>Reference vertex indices</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_encoded">
<code class="descclassname">trimesh.util.</code><code class="descname">array_to_encoded</code><span class="sig-paren">(</span><em>array</em>, <em>dtype=None</em>, <em>encoding='base64'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a numpy array to a compact serializable dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">array</span></dt><dd><p>Any numpy array</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str or None</span></dt><dd><p>Optional dtype to encode array</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">str</span></dt><dd><p>‘base64’ or ‘binary’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>encoded</strong><span class="classifier">dict</span></dt><dd><p>Has keys:
‘dtype’:  str, of dtype
‘shape’:  tuple of shape
‘base64’: str, base64 encoded string</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.array_to_string">
<code class="descclassname">trimesh.util.</code><code class="descname">array_to_string</code><span class="sig-paren">(</span><em>array</em>, <em>col_delim=' '</em>, <em>row_delim='\n'</em>, <em>digits=8</em>, <em>value_format='{}'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.array_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a 1 or 2D array into a string with a specified number
of digits and delimiter. The reason this exists is that the
basic numpy array to string conversions are surprisingly bad.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">(n,) or (n, d) float or int</span></dt><dd><p>Data to be converted
If shape is (n,) only column delimiter will be used</p>
</dd>
<dt><strong>col_delim</strong><span class="classifier">str</span></dt><dd><p>What string should separate values in a column</p>
</dd>
<dt><strong>row_delim</strong><span class="classifier">str</span></dt><dd><p>What string should separate values in a row</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>How many digits should floating point numbers include</p>
</dd>
<dt><strong>value_format</strong><span class="classifier">str</span></dt><dd><p>Format string for each value or sequence of values
If multiple values per value_format it must divide
into array evenly.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>formatted</strong><span class="classifier">str</span></dt><dd><p>String representation of original array</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.attach_to_log">
<code class="descclassname">trimesh.util.</code><code class="descname">attach_to_log</code><span class="sig-paren">(</span><em>level=10, handler=None, loggers=None, colors=True, capture_warnings=True, blacklist=['TerminalIPythonApp', 'PYREADLINE', 'pyembree', 'shapely.geos', 'shapely.speedups._speedups']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.attach_to_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a stream handler to all loggers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level:     logging level</strong></dt><dd></dd>
<dt><strong>handler:   log handler object</strong></dt><dd></dd>
<dt><strong>loggers:   list of loggers to attach to</strong></dt><dd><p>if None, will try to attach to all available</p>
</dd>
<dt><strong>colors:    bool, if True try to use colorlog formatter</strong></dt><dd></dd>
<dt><strong>blacklist: list of str, names of loggers NOT to attach to</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.bounds_tree">
<code class="descclassname">trimesh.util.</code><code class="descname">bounds_tree</code><span class="sig-paren">(</span><em>bounds</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.bounds_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of axis aligned bounds, create an r-tree for broad- phase
collision detection</p>
<dl class="simple">
<dt>bounds: (n, dimension*2) list of non- interleaved bounds</dt><dd><p>for a 2D bounds tree:
[(minx, miny, maxx, maxy), …]</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree: Rtree object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.compress">
<code class="descclassname">trimesh.util.</code><code class="descname">compress</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress data stored in a dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>info</strong><span class="classifier">dict</span></dt><dd><p>Data to compress in form:
{file name in archive: bytes or file-like object}</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>compressed</strong><span class="classifier">bytes</span></dt><dd><p>Compressed file data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.concatenate">
<code class="descclassname">trimesh.util.</code><code class="descname">concatenate</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two or more meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a: Trimesh object, or list of such</strong></dt><dd></dd>
<dt><strong>b: Trimesh object, or list of such</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result: Trimesh object containing concatenated mesh</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.convert_like">
<code class="descclassname">trimesh.util.</code><code class="descname">convert_like</code><span class="sig-paren">(</span><em>item</em>, <em>like</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.convert_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an item to have the dtype of another item</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>item: item to be converted</strong></dt><dd></dd>
<dt><strong>like: object with target dtype. If None, item is returned unmodified</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result: item, but in dtype of like</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decimal_to_digits">
<code class="descclassname">trimesh.util.</code><code class="descname">decimal_to_digits</code><span class="sig-paren">(</span><em>decimal</em>, <em>min_digits=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decimal_to_digits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of digits to the first nonzero decimal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>decimal:    float</strong></dt><dd></dd>
<dt><strong>min_digits: int, minimum number of digits to return</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>digits: int, number of digits to the first nonzero decimal</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decode_keys">
<code class="descclassname">trimesh.util.</code><code class="descname">decode_keys</code><span class="sig-paren">(</span><em>store</em>, <em>encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decode_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>If a dictionary has keys that are bytes decode them to a str.</p>
<dl class="simple">
<dt>store<span class="classifier">dict</span></dt><dd><p>Dictionary with data</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">dict</span></dt><dd><p>Values are untouched but keys that were bytes
are converted to ASCII strings.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.decompress">
<code class="descclassname">trimesh.util.</code><code class="descname">decompress</code><span class="sig-paren">(</span><em>file_obj</em>, <em>file_type</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.decompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an open file object and a file type, return all components
of the archive as open file objects in a dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_obj</strong><span class="classifier">file-like</span></dt><dd><p>Containing compressed data</p>
</dd>
<dt><strong>file_type</strong><span class="classifier">str</span></dt><dd><p>File extension, ‘zip’, ‘tar.gz’, etc</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>decompressed</strong><span class="classifier">dict</span></dt><dd><p>Data from archive in format {file name : file-like}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.diagonal_dot">
<code class="descclassname">trimesh.util.</code><code class="descname">diagonal_dot</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.diagonal_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product by row of a and b.</p>
<p>There are a lot of ways to do this though
performance varies very widely. This method
uses the dot product to sum the row and avoids
function calls if at all possible.</p>
<p>Comparing performance of some equivalent versions:
<a href="#id11"><span class="problematic" id="id12">``</span></a>`
In [1]: import numpy as np; import trimesh</p>
<p>In [2]: a = np.random.random((10000, 3))</p>
<p>In [3]: b = np.random.random((10000, 3))</p>
<p>In [4]: %timeit (a * b).sum(axis=1)
1000 loops, best of 3: 181 us per loop</p>
<p>In [5]: %timeit np.einsum(‘ij,ij-&gt;i’, a, b)
10000 loops, best of 3: 62.7 us per loop</p>
<p>In [6]: %timeit np.diag(np.dot(a, b.T))
1 loop, best of 3: 429 ms per loop</p>
<p>In [7]: %timeit np.dot(a * b, np.ones(a.shape[1]))
10000 loops, best of 3: 61.3 us per loop</p>
<p>In [8]: %timeit trimesh.util.diagonal_dot(a, b)
10000 loops, best of 3: 55.2 us per loop
<a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(m, d) float</span></dt><dd><p>First array</p>
</dd>
<dt><strong>b</strong><span class="classifier">(m, d) float</span></dt><dd><p>Second array</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">(m,) float</span></dt><dd><p>Dot product of each row</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.distance_to_end">
<code class="descclassname">trimesh.util.</code><code class="descname">distance_to_end</code><span class="sig-paren">(</span><em>file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.distance_to_end" title="Permalink to this definition">¶</a></dt>
<dd><p>For an open file object how far is it to the end</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_obj: open file- like object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance: int, bytes to end of file</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.encoded_to_array">
<code class="descclassname">trimesh.util.</code><code class="descname">encoded_to_array</code><span class="sig-paren">(</span><em>encoded</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.encoded_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a dictionary with base64 encoded strings back into a numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>encoded</strong><span class="classifier">dict</span></dt><dd><dl class="simple">
<dt>Has keys:</dt><dd><p>dtype: string of dtype
shape: int tuple of shape
base64: base64 encoded string of flat array
binary:  decode result coming from numpy.tostring</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>array: numpy array</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.euclidean">
<code class="descclassname">trimesh.util.</code><code class="descname">euclidean</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.euclidean" title="Permalink to this definition">¶</a></dt>
<dd><p>Euclidean distance between vectors a and b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">(n,) float</span></dt><dd><p>First vector</p>
</dd>
<dt><strong>b</strong><span class="classifier">(n,) float</span></dt><dd><p>Second vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>distance</strong><span class="classifier">float</span></dt><dd><p>Euclidean distance between A and B</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.generate_basis">
<code class="descclassname">trimesh.util.</code><code class="descname">generate_basis</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.generate_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an arbitrary basis (also known as a coordinate frame)
from a given z-axis vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>z: (3,) float</strong></dt><dd><p>A vector along the positive z-axis</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(3,) float</span></dt><dd><p>Vector along x axis</p>
</dd>
<dt><strong>y</strong><span class="classifier">(3,) float</span></dt><dd><p>Vector along y axis</p>
</dd>
<dt><strong>z</strong><span class="classifier">(3,) float</span></dt><dd><p>Vector along z axis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_arange">
<code class="descclassname">trimesh.util.</code><code class="descname">grid_arange</code><span class="sig-paren">(</span><em>bounds</em>, <em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid from an (2,dimension) bounds with samples step distance apart.</p>
<p>bounds: (2,dimension) list of [[min x, min y, etc], [max x, max y, etc]]
step:   float, or (dimension) floats, separation between points</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grid: (n, dimension), points inside the specified bounds</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.grid_linspace">
<code class="descclassname">trimesh.util.</code><code class="descname">grid_linspace</code><span class="sig-paren">(</span><em>bounds</em>, <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.grid_linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid spaced inside a bounding box with edges spaced using np.linspace.</p>
<p>bounds: (2,dimension) list of [[min x, min y, etc], [max x, max y, etc]]
count:  int, or (dimension,) int, number of samples per side</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>grid: (n, dimension) float, points in the specified bounds</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.hash_file">
<code class="descclassname">trimesh.util.</code><code class="descname">hash_file</code><span class="sig-paren">(</span><em>file_obj</em>, <em>hash_function=&lt;built-in function openssl_md5&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.hash_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the hash of an open file- like object.</p>
<p>file_obj: file like object
hash_function: function to use to hash data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hashed: str, hex version of result</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_binary_file">
<code class="descclassname">trimesh.util.</code><code class="descname">is_binary_file</code><span class="sig-paren">(</span><em>file_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_binary_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if file has non-ASCII characters (&gt; 0x7F, or 127)
Should work in both Python 2 and 3</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_file">
<code class="descclassname">trimesh.util.</code><code class="descname">is_file</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is file- like</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>Any object type to be checked</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_file</strong><span class="classifier">bool</span></dt><dd><p>True if object is a file</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_instance_named">
<code class="descclassname">trimesh.util.</code><code class="descname">is_instance_named</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_instance_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a member of the class ‘name’,
or a subclass of ‘name’, return True.</p>
<dl class="simple">
<dt>obj<span class="classifier">instance</span></dt><dd><p>Some object of some class</p>
</dd>
<dt>name: str</dt><dd><p>The name of the class we want to check for</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>is_instance</strong><span class="classifier">bool</span></dt><dd><p>Whether the object is a member of the named class</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_none">
<code class="descclassname">trimesh.util.</code><code class="descname">is_none</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if an object is None or not.</p>
<p>Handles the case of np.array(None) as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>Any object type to be checked</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_none</strong><span class="classifier">bool</span></dt><dd><p>True if obj is None or numpy None-like</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_sequence">
<code class="descclassname">trimesh.util.</code><code class="descname">is_sequence</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a sequence or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>Any object type to be checked</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_sequence</strong><span class="classifier">bool</span></dt><dd><p>True if object is sequence</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_shape">
<code class="descclassname">trimesh.util.</code><code class="descname">is_shape</code><span class="sig-paren">(</span><em>obj</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the shape of a numpy.ndarray to a target shape,
with any value less than zero being considered a wildcard</p>
<p>Note that if a list- like object is passed that is not a numpy
array, this function will not convert it and will return False.</p>
<dl class="simple">
<dt>obj<span class="classifier">np.ndarray</span></dt><dd><p>Array to check the shape on</p>
</dd>
<dt>shape<span class="classifier">list or tuple</span></dt><dd><p>Any negative term will be considered a wildcard
Any tuple term will be evaluated as an OR</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape_ok: bool, True if shape of obj matches query shape</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: a = np.random.random((100, 3))</p>
<p>In [2]: a.shape
Out[2]: (100, 3)</p>
<p>In [3]: trimesh.util.is_shape(a, (-1, 3))
Out[3]: True</p>
<p>In [4]: trimesh.util.is_shape(a, (-1, 3, 5))
Out[4]: False</p>
<p>In [5]: trimesh.util.is_shape(a, (100, -1))
Out[5]: True</p>
<p>In [6]: trimesh.util.is_shape(a, (-1, (3, 4)))
Out[6]: True</p>
<p>In [7]: trimesh.util.is_shape(a, (-1, (4, 5)))
Out[7]: False</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.is_string">
<code class="descclassname">trimesh.util.</code><code class="descname">is_string</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object is a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>Any object type to be checked</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_string</strong><span class="classifier">bool</span></dt><dd><p>True if obj is a string</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.isclose">
<code class="descclassname">trimesh.util.</code><code class="descname">isclose</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>atol</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>A replacement for np.isclose that does fewer checks
and validation and as a result is roughly 4x faster.</p>
<p>Note that this is used in tight loops, and as such
a and b MUST be np.ndarray, not list or “array-like”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">np.ndarray</span></dt><dd><p>To be compared</p>
</dd>
<dt><strong>b</strong><span class="classifier">np.ndarray</span></dt><dd><p>To be compared</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Acceptable distance between <cite>a</cite> and <cite>b</cite> to be “close”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>close</strong><span class="classifier">np.ndarray, bool</span></dt><dd><p>Per- element closeness</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.jsonify">
<code class="descclassname">trimesh.util.</code><code class="descname">jsonify</code><span class="sig-paren">(</span><em>obj</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.jsonify" title="Permalink to this definition">¶</a></dt>
<dd><p>A version of json.dumps that can handle numpy arrays
by creating a custom encoder for numpy dtypes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">JSON- serializable blob</span></dt><dd></dd>
<dt><strong>**kwargs :</strong></dt><dd><p>Passed to json.dumps</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dumped</strong><span class="classifier">str</span></dt><dd><p>JSON dump of obj</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.make_sequence">
<code class="descclassname">trimesh.util.</code><code class="descname">make_sequence</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.make_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an object, if it is a sequence return, otherwise
add it to a length 1 sequence and return.</p>
<p>Useful for wrapping functions which sometimes return single
objects and other times return lists of objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj</strong><span class="classifier">object</span></dt><dd><p>An object to be made a sequence</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>as_sequence</strong><span class="classifier">(n,) sequence</span></dt><dd><p>Contains input value</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.md5_object">
<code class="descclassname">trimesh.util.</code><code class="descname">md5_object</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.md5_object" title="Permalink to this definition">¶</a></dt>
<dd><p>If an object is hashable, return the string of the MD5.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>md5: str, MD5 hash</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.multi_dict">
<code class="descclassname">trimesh.util.</code><code class="descname">multi_dict</code><span class="sig-paren">(</span><em>pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.multi_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a set of key value pairs, create a dictionary.
If a key occurs multiple times, stack the values into an array.</p>
<p>Can be called like the regular dict(pairs) constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pairs: (n,2) array of key, value pairs</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result: dict, with all values stored (rather than last with regular dict)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.pairwise">
<code class="descclassname">trimesh.util.</code><code class="descname">pairwise</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>For an iterable, group values into pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>iterable</strong><span class="classifier">(m, ) list</span></dt><dd><p>A sequence of values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs: (n, 2)</strong></dt><dd><p>Pairs of sequential values</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_int">
<code class="descclassname">trimesh.util.</code><code class="descname">sigfig_int</code><span class="sig-paren">(</span><em>values</em>, <em>sigfig</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of floating point values into integers with a specified number
of significant figures and an exponent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values: (n,) float or int, array of values</strong></dt><dd></dd>
<dt><strong>sigfig: (n,) int, number of significant figures to keep</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>as_int:      (n,) int, every value[i] has sigfig[i] digits</strong></dt><dd></dd>
<dt><strong>multiplier:  (n, int), exponent, so as_int * 10 ** multiplier is</strong></dt><dd><p>the same order of magnitude as the input</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.sigfig_round">
<code class="descclassname">trimesh.util.</code><code class="descname">sigfig_round</code><span class="sig-paren">(</span><em>values</em>, <em>sigfig=1</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.sigfig_round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a single value to a specified number of significant figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values: float, value to be rounded</strong></dt><dd></dd>
<dt><strong>sigfig: int, number of significant figures to reduce to</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rounded: values, but rounded to the specified number of significant figures</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>In [1]: trimesh.util.round_sigfig(-232453.00014045456, 1)
Out[1]: -200000.0</p>
<p>In [2]: trimesh.util.round_sigfig(.00014045456, 1)
Out[2]: 0.0001</p>
<p>In [3]: trimesh.util.round_sigfig(.00014045456, 4)
Out[3]: 0.0001405</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.spherical_to_vector">
<code class="descclassname">trimesh.util.</code><code class="descname">spherical_to_vector</code><span class="sig-paren">(</span><em>spherical</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.spherical_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of (n,2) spherical vectors to (n,3) vectors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>spherical</strong><span class="classifier">(n , 2) float</span></dt><dd><p>Angles, in radians</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Unit vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.split_extension">
<code class="descclassname">trimesh.util.</code><code class="descname">split_extension</code><span class="sig-paren">(</span><em>file_name, special=['tar.bz2', 'tar.gz']</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.split_extension" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the file extension of a file name, including support for
special case multipart file extensions (like .tar.gz)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_name: str, file name</strong></dt><dd></dd>
<dt><strong>special:   list of str, multipart extensions</strong></dt><dd><p>eg: [‘tar.bz2’, ‘tar.gz’]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>extension: str, last charecters after a period, or</strong></dt><dd><p>a value from ‘special’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.stack_3D">
<code class="descclassname">trimesh.util.</code><code class="descname">stack_3D</code><span class="sig-paren">(</span><em>points</em>, <em>return_2D=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.stack_3D" title="Permalink to this definition">¶</a></dt>
<dd><p>For a list of (n, 2) or (n, 3) points return them
as (n, 3) 3D points, 2D points on the XY plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, 2) or (n, 3) float</span></dt><dd><p>Points in either 2D or 3D space</p>
</dd>
<dt><strong>return_2D</strong><span class="classifier">bool</span></dt><dd><p>Were the original points 2D?</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in space</p>
</dd>
<dt><strong>is_2D</strong><span class="classifier">bool</span></dt><dd><p>Only returned if return_2D
If source points were (n, 2) True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.stack_lines">
<code class="descclassname">trimesh.util.</code><code class="descname">stack_lines</code><span class="sig-paren">(</span><em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.stack_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack a list of values that represent a polyline into
individual line segments with duplicated consecutive values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: sequence of items</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked: (n,2) set of items</strong></dt><dd></dd>
<dt><strong>In [1]: trimesh.util.stack_lines([0,1,2])</strong></dt><dd></dd>
<dt><strong>Out[1]:</strong></dt><dd></dd>
<dt><strong>array([[0, 1],</strong></dt><dd><p>[1, 2]])</p>
</dd>
<dt><strong>In [2]: trimesh.util.stack_lines([0,1,2,4,5])</strong></dt><dd></dd>
<dt><strong>Out[2]:</strong></dt><dd></dd>
<dt><strong>array([[0, 1],</strong></dt><dd><p>[1, 2],
[2, 4],
[4, 5]])</p>
</dd>
<dt><strong>In [3]: trimesh.util.stack_lines([[0,0],[1,1],[2,2], [3,3]])</strong></dt><dd></dd>
<dt><strong>Out[3]:</strong></dt><dd></dd>
<dt><strong>array([[0, 0],</strong></dt><dd><p>[1, 1],
[1, 1],
[2, 2],
[2, 2],
[3, 3]])</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.submesh">
<code class="descclassname">trimesh.util.</code><code class="descname">submesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>faces_sequence</em>, <em>only_watertight=False</em>, <em>append=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.submesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">Trimesh</span></dt><dd><p>Source mesh to take geometry from</p>
</dd>
<dt><strong>faces_sequence</strong><span class="classifier">sequence (p,) int</span></dt><dd><p>Indexes of mesh.faces</p>
</dd>
<dt><strong>only_watertight</strong><span class="classifier">bool</span></dt><dd><p>Only return submeshes which are watertight.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool</span></dt><dd><p>Return a single mesh which has the faces appended,
if this flag is set, only_watertight is ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>if append</strong><span class="classifier">Trimesh object</span></dt><dd></dd>
<dt><strong>else        list of Trimesh objects</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.tolist">
<code class="descclassname">trimesh.util.</code><code class="descname">tolist</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that any arrays or dicts passed containing
numpy arrays are properly converted to lists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">any</span></dt><dd><p>Usually a dict with some numpy arrays as values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">any</span></dt><dd><p>JSON- serializable version of data</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.triangle_strips_to_faces">
<code class="descclassname">trimesh.util.</code><code class="descname">triangle_strips_to_faces</code><span class="sig-paren">(</span><em>strips</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.triangle_strips_to_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of triangle strips, convert them to (n,3) faces.</p>
<p>Processes all strips at once using np.concatenate and is significantly
faster than loop- based methods.</p>
<p>From the OpenGL programming guide describing a single triangle
strip [v0, v1, v2, v3, v4]:</p>
<p>Draws a series of triangles (three-sided polygons) using vertices
v0, v1, v2, then v2, v1, v3  (note the order), then v2, v3, v4,
and so on. The ordering is to ensure that the triangles are all
drawn with the same orientation so that the strip can correctly form
part of a surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>strips: (n,) list of (m,) int vertex indices</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>faces: (m,3) int, vertex indices representing triangles</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_bases">
<code class="descclassname">trimesh.util.</code><code class="descname">type_bases</code><span class="sig-paren">(</span><em>obj</em>, <em>depth=4</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bases of the object passed.</p>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.type_named">
<code class="descclassname">trimesh.util.</code><code class="descname">type_named</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.type_named" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to the type() builtin, but looks in class bases
for named instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>obj: object to look for class of</strong></dt><dd></dd>
<dt><strong>name</strong><span class="classifier">str, name of class</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>named class, or None</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unique_bincount">
<code class="descclassname">trimesh.util.</code><code class="descname">unique_bincount</code><span class="sig-paren">(</span><em>values</em>, <em>minlength</em>, <em>return_inverse=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unique_bincount" title="Permalink to this definition">¶</a></dt>
<dd><p>For arrays of integers find unique values using bin counting.
Roughly 10x faster for correct input than np.unique</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">(n,) int</span></dt><dd><p>Values to find unique members of</p>
</dd>
<dt><strong>minlength</strong><span class="classifier">int</span></dt><dd><p>Maximum value that will occur in values (values.max())</p>
</dd>
<dt><strong>return_inverse</strong><span class="classifier">bool</span></dt><dd><p>If True, return an inverse such that unique[inverse] == values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>unique</strong><span class="classifier">(m,) int</span></dt><dd><p>Unique values in original array</p>
</dd>
<dt><strong>inverse</strong><span class="classifier">(n,) int</span></dt><dd><p>An array such that unique[inverse] == values
Only returned if return_inverse is True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unique_id">
<code class="descclassname">trimesh.util.</code><code class="descname">unique_id</code><span class="sig-paren">(</span><em>length=12</em>, <em>increment=0</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unique_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a decent looking alphanumeric unique identifier.
First 16 bits are time- incrementing, followed by randomness.</p>
<p>This function is used as a nicer looking alternative to:
&gt;&gt;&gt; uuid.uuid4().hex</p>
<p>Follows the advice in:
<a class="reference external" href="https://eager.io/blog/how-long-does-an-id-need-to-be/">https://eager.io/blog/how-long-does-an-id-need-to-be/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length:    int, length of resulting identifier</strong></dt><dd></dd>
<dt><strong>increment: int, number to add to header uint16</strong></dt><dd><p>useful if calling this function repeatedly
in a tight loop executing faster than time
can increment the header</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>————</strong></dt><dd></dd>
<dt><strong>unique: str, unique alphanumeric identifier</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.unitize">
<code class="descclassname">trimesh.util.</code><code class="descname">unitize</code><span class="sig-paren">(</span><em>vectors</em>, <em>check_valid=False</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.unitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitize a vector or an array or row- vectors.</p>
<dl class="simple">
<dt>vectors<span class="classifier">(n,m) or (j) float</span></dt><dd><p>Vector or vectors to be unitized</p>
</dd>
<dt>check_valid<span class="classifier">bool</span></dt><dd><p>If set, will return mask of nonzero vectors</p>
</dd>
<dt>threshold<span class="classifier">float</span></dt><dd><p>Cutoff for a value to be considered zero.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>unit</strong><span class="classifier">(n,m) or (j) float</span></dt><dd><p>Input vectors but unitized</p>
</dd>
<dt><strong>valid</strong><span class="classifier">(n,) bool or bool</span></dt><dd><p>Mask of nonzero vectors returned if <cite>check_valid</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_hemisphere">
<code class="descclassname">trimesh.util.</code><code class="descname">vector_hemisphere</code><span class="sig-paren">(</span><em>vectors</em>, <em>return_sign=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_hemisphere" title="Permalink to this definition">¶</a></dt>
<dd><p>For a set of 3D vectors alter the sign so they are all in the
upper hemisphere.</p>
<p>If the vector lies on the plane all vectors with negative Y
will be reversed.</p>
<p>If the vector has a zero Z and Y value vectors with a
negative X value will be reversed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">(n,3) float</span></dt><dd><p>Input vectors</p>
</dd>
<dt><strong>return_sign</strong><span class="classifier">bool</span></dt><dd><p>Return the sign mask or not</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>oriented: (n, 3) float</strong></dt><dd><p>Vectors with same magnitude as source
but possibly reversed to ensure all vectors
are in the same hemisphere.</p>
</dd>
<dt><strong>sign</strong><span class="classifier">(n,) float</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vector_to_spherical">
<code class="descclassname">trimesh.util.</code><code class="descname">vector_to_spherical</code><span class="sig-paren">(</span><em>cartesian</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vector_to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of cartesian points to (n,2) spherical unit
vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cartesian</strong><span class="classifier">(n, 3) float</span></dt><dd><p>Points in space</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>spherical</strong><span class="classifier">(n, 2) float</span></dt><dd><p>Angles, in radians</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.vstack_empty">
<code class="descclassname">trimesh.util.</code><code class="descname">vstack_empty</code><span class="sig-paren">(</span><em>tup</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.vstack_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>A thin wrapper for numpy.vstack that ignores empty lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tup: tuple or list of arrays with the same number of columns</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stacked: (n,d) array, with same number of columns as</strong></dt><dd><p>constituent arrays.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.wrap_as_stream">
<code class="descclassname">trimesh.util.</code><code class="descname">wrap_as_stream</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.wrap_as_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap a string or bytes object as a file object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>item: str or bytes</strong></dt><dd><p>Item to be wrapped</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>wrapped: file-like object</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.write_encoded">
<code class="descclassname">trimesh.util.</code><code class="descname">write_encoded</code><span class="sig-paren">(</span><em>file_obj</em>, <em>stuff</em>, <em>encoding='utf-8'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.write_encoded" title="Permalink to this definition">¶</a></dt>
<dd><p>If a file is open in binary mode and a string is passed, encode and write
If a file is open in text   mode and bytes are passed, decode and write</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>file_obj: file object,  with ‘write’ and ‘mode’</strong></dt><dd></dd>
<dt><strong>stuff:    str or bytes, stuff to be written</strong></dt><dd></dd>
<dt><strong>encoding: str,          encoding of text</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.util.zero_pad">
<code class="descclassname">trimesh.util.</code><code class="descname">zero_pad</code><span class="sig-paren">(</span><em>data</em>, <em>count</em>, <em>right=True</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.util.zero_pad" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>data<span class="classifier">(n,)</span></dt><dd><p>1D array</p>
</dd>
<dt>count<span class="classifier">int</span></dt><dd><p>Minimum length of result array</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>padded</strong><span class="classifier">(m,)</span></dt><dd><p>1D array where m &gt;= count</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh.version">
<span id="trimesh-version-module"></span><h2>trimesh.version module<a class="headerlink" href="#module-trimesh.version" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-trimesh.voxel">
<span id="trimesh-voxel-module"></span><h2>trimesh.voxel module<a class="headerlink" href="#module-trimesh.voxel" title="Permalink to this headline">¶</a></h2>
<div class="section" id="voxel-py">
<h3>voxel.py<a class="headerlink" href="#voxel-py" title="Permalink to this headline">¶</a></h3>
<p>Convert meshes to a simple voxel data structure and back again.</p>
<dl class="class">
<dt id="trimesh.voxel.Voxel">
<em class="property">class </em><code class="descclassname">trimesh.voxel.</code><code class="descname">Voxel</code><span class="sig-paren">(</span><em>matrix</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.voxel.VoxelBase" title="trimesh.voxel.VoxelBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.voxel.VoxelBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled_count</span></code></dt><dd><p>Return the number of voxels that are occupied.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">marching_cubes</span></code></dt><dd><p>A marching cubes Trimesh representation of the voxels.</p>
</dd>
<dt><strong>matrix</strong></dt><dd></dd>
<dt><strong>origin</strong></dt><dd></dd>
<dt><strong>pitch</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></dt><dd><p>The center of each filled cell as a list of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>The shape of the matrix for the current voxel object.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></dt><dd><p>What is the volume of the filled cells in the current voxel object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.voxel.Voxel.as_boxes" title="trimesh.voxel.Voxel.as_boxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_boxes</span></code></a>()</p></td>
<td><p>A rough Trimesh representation of the voxels with a box for each filled voxel.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_filled</span></code>(point)</p></td>
<td><p>Query a point to see if the voxel cell it lies in is filled or not.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_to_index</span></code>(point)</p></td>
<td><p>Convert a point to an index in the matrix array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.voxel.Voxel.show" title="trimesh.voxel.Voxel.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>(*args, **kwargs)</p></td>
<td><p>Convert the current set of voxels into a trimesh for visualization and show that via its built- in preview method.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.voxel.Voxel.as_boxes">
<code class="descname">as_boxes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel.as_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>A rough Trimesh representation of the voxels with a box
for each filled voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh: Trimesh object made up of one box per filled cell.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#trimesh.voxel.Voxel.matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.Voxel.origin">
<code class="descname">origin</code><a class="headerlink" href="#trimesh.voxel.Voxel.origin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.voxel.Voxel.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.Voxel.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current set of voxels into a trimesh for visualization
and show that via its built- in preview method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.voxel.VoxelBase">
<em class="property">class </em><code class="descclassname">trimesh.voxel.</code><code class="descname">VoxelBase</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#trimesh.voxel.VoxelBase.filled_count" title="trimesh.voxel.VoxelBase.filled_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled_count</span></code></a></dt><dd><p>Return the number of voxels that are occupied.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelBase.marching_cubes" title="trimesh.voxel.VoxelBase.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">marching_cubes</span></code></a></dt><dd><p>A marching cubes Trimesh representation of the voxels.</p>
</dd>
<dt><strong>pitch</strong></dt><dd></dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelBase.points" title="trimesh.voxel.VoxelBase.points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></a></dt><dd><p>The center of each filled cell as a list of points.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelBase.shape" title="trimesh.voxel.VoxelBase.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>The shape of the matrix for the current voxel object.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelBase.volume" title="trimesh.voxel.VoxelBase.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></dt><dd><p>What is the volume of the filled cells in the current voxel object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.voxel.VoxelBase.is_filled" title="trimesh.voxel.VoxelBase.is_filled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_filled</span></code></a>(point)</p></td>
<td><p>Query a point to see if the voxel cell it lies in is filled or not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.voxel.VoxelBase.point_to_index" title="trimesh.voxel.VoxelBase.point_to_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_to_index</span></code></a>(point)</p></td>
<td><p>Convert a point to an index in the matrix array.</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.filled_count">
<code class="descname">filled_count</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.filled_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of voxels that are occupied.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filled: int, number of voxels that are occupied</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.voxel.VoxelBase.is_filled">
<code class="descname">is_filled</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelBase.is_filled" title="Permalink to this definition">¶</a></dt>
<dd><p>Query a point to see if the voxel cell it lies in is filled or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point: (3,) float, point in space</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_filled: bool, is cell occupied or not</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.marching_cubes">
<code class="descname">marching_cubes</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.marching_cubes" title="Permalink to this definition">¶</a></dt>
<dd><p>A marching cubes Trimesh representation of the voxels.</p>
<p>No effort was made to clean or smooth the result in any way;
it is merely the result of applying the scikit-image
measure.marching_cubes function to self.matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>meshed: Trimesh object representing the current voxel</strong></dt><dd><p>object, as returned by marching cubes algorithm.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.pitch">
<code class="descname">pitch</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.pitch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="trimesh.voxel.VoxelBase.point_to_index">
<code class="descname">point_to_index</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelBase.point_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a point to an index in the matrix array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>point: (3,) float, point in space</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>index: (3,) int tuple, index in self.matrix</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.points">
<code class="descname">points</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.points" title="Permalink to this definition">¶</a></dt>
<dd><p>The center of each filled cell as a list of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (self.filled, 3) float, list of points</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.shape">
<code class="descname">shape</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the matrix for the current voxel object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape: (3,) int, what is the shape of the 3D matrix</strong></dt><dd><p>for these voxels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelBase.volume">
<code class="descname">volume</code><a class="headerlink" href="#trimesh.voxel.VoxelBase.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>What is the volume of the filled cells in the current voxel object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume: float, volume of filled cells</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="trimesh.voxel.VoxelMesh">
<em class="property">class </em><code class="descclassname">trimesh.voxel.</code><code class="descname">VoxelMesh</code><span class="sig-paren">(</span><em>mesh</em>, <em>pitch</em>, <em>max_iter=10</em>, <em>size_max=None</em>, <em>method='subdivide'</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#trimesh.voxel.VoxelBase" title="trimesh.voxel.VoxelBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">trimesh.voxel.VoxelBase</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled_count</span></code></dt><dd><p>Return the number of voxels that are occupied.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">marching_cubes</span></code></dt><dd><p>A marching cubes Trimesh representation of the voxels.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix" title="trimesh.voxel.VoxelMesh.matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix</span></code></a></dt><dd><p>A matrix representation of the surface voxels.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix_solid" title="trimesh.voxel.VoxelMesh.matrix_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_solid</span></code></a></dt><dd><p>The voxels in a mesh as a 3D matrix.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.matrix_surface" title="trimesh.voxel.VoxelMesh.matrix_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_surface</span></code></a></dt><dd><p>The voxels on the surface of the mesh as a 3D matrix.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.origin" title="trimesh.voxel.VoxelMesh.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></dt><dd><p>The origin of the voxel array.</p>
</dd>
<dt><strong>pitch</strong></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></dt><dd><p>The center of each filled cell as a list of points.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></dt><dd><p>The shape of the matrix for the current voxel object.</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.sparse_solid" title="trimesh.voxel.VoxelMesh.sparse_solid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_solid</span></code></a></dt><dd><p>Filled cells inside and on the surface of mesh</p>
</dd>
<dt><a class="reference internal" href="#trimesh.voxel.VoxelMesh.sparse_surface" title="trimesh.voxel.VoxelMesh.sparse_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_surface</span></code></a></dt><dd><p>Filled cells on the surface of the mesh.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></dt><dd><p>What is the volume of the filled cells in the current voxel object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#trimesh.voxel.VoxelMesh.as_boxes" title="trimesh.voxel.VoxelMesh.as_boxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_boxes</span></code></a>([solid])</p></td>
<td><p>A rough Trimesh representation of the voxels with a box for each filled voxel.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_filled</span></code>(point)</p></td>
<td><p>Query a point to see if the voxel cell it lies in is filled or not.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_to_index</span></code>(point)</p></td>
<td><p>Convert a point to an index in the matrix array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#trimesh.voxel.VoxelMesh.show" title="trimesh.voxel.VoxelMesh.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>([solid])</p></td>
<td><p>Convert the current set of voxels into a trimesh for visualization and show that via its built- in preview method.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="trimesh.voxel.VoxelMesh.as_boxes">
<code class="descname">as_boxes</code><span class="sig-paren">(</span><em>solid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh.as_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>A rough Trimesh representation of the voxels with a box
for each filled voxel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>solid: bool, if True return boxes for sparse_solid</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh: Trimesh object made up of one box per filled cell.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>A matrix representation of the surface voxels.</p>
<p>In the future this is planned to return a filled voxel matrix
if the source mesh is watertight, and a surface voxelization
otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: self.shape np.bool, cell occupancy</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix_solid">
<code class="descname">matrix_solid</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>The voxels in a mesh as a 3D matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: self.shape np.bool, if a cell is True it is occupied</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.matrix_surface">
<code class="descname">matrix_surface</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.matrix_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>The voxels on the surface of the mesh as a 3D matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: self.shape np.bool, if a cell is True it is occupied</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.origin">
<code class="descname">origin</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The origin of the voxel array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>origin: (3,) float, point in space</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="trimesh.voxel.VoxelMesh.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>solid=False</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.VoxelMesh.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the current set of voxels into a trimesh for visualization
and show that via its built- in preview method.</p>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.sparse_solid">
<code class="descname">sparse_solid</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.sparse_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>Filled cells inside and on the surface of mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filled: (n, 3) int, filled cells in or on mesh.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="trimesh.voxel.VoxelMesh.sparse_surface">
<code class="descname">sparse_surface</code><a class="headerlink" href="#trimesh.voxel.VoxelMesh.sparse_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Filled cells on the surface of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>voxels: (n, 3) int, filled cells on mesh surface</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.boolean_sparse">
<code class="descclassname">trimesh.voxel.</code><code class="descname">boolean_sparse</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>operation=&lt;ufunc 'logical_and'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.boolean_sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Find common rows between two arrays very quickly
using 3D boolean sparse matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a: (n, d)  int, coordinates in space</strong></dt><dd></dd>
<dt><strong>b: (m, d)  int, coordinates in space</strong></dt><dd></dd>
<dt><strong>operation: numpy operation function, ie:</strong></dt><dd><p>np.logical_and
np.logical_or</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords: (q, d) int, coordinates in space</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.fill_voxelization">
<code class="descclassname">trimesh.voxel.</code><code class="descname">fill_voxelization</code><span class="sig-paren">(</span><em>occupied</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.fill_voxelization" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sparse surface voxelization, fill in between columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>occupied: (n, 3) int, location of filled cells</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filled: (m, 3) int, location of filled cells</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.indices_to_points">
<code class="descclassname">trimesh.voxel.</code><code class="descname">indices_to_points</code><span class="sig-paren">(</span><em>indices</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.indices_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert indices of an (n,m,p) matrix into a set of voxel center points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: (q, 3) int, index of voxel matrix (n,m,p)</strong></dt><dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt><dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points: (q, 3) float, list of points</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.local_voxelize">
<code class="descclassname">trimesh.voxel.</code><code class="descname">local_voxelize</code><span class="sig-paren">(</span><em>mesh</em>, <em>point</em>, <em>pitch</em>, <em>radius</em>, <em>fill=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.local_voxelize" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxelize a mesh in the region of a cube around a point. When fill=True,
uses proximity.contains to fill the resulting voxels so may be meaningless
for non-watertight meshes. Useful to reduce memory cost for small values of
pitch as opposed to global voxelization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mesh</strong><span class="classifier">trimesh.Trimesh</span></dt><dd><p>Source geometry</p>
</dd>
<dt><strong>point</strong><span class="classifier">(3, ) float</span></dt><dd><p>Point in space to voxelize around</p>
</dd>
<dt><strong>pitch</strong><span class="classifier">float</span></dt><dd><p>Side length of a single voxel cube</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>Number of voxel cubes to return in each direction.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">parameters to pass to voxelize_subdivide</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>voxels</strong><span class="classifier">(m, m, m) bool</span></dt><dd><p>Array of local voxels where m=2*radius+1</p>
</dd>
<dt><strong>origin_position</strong><span class="classifier">(3,) float</span></dt><dd><p>Position of the voxel grid origin in space</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.matrix_to_marching_cubes">
<code class="descclassname">trimesh.voxel.</code><code class="descname">matrix_to_marching_cubes</code><span class="sig-paren">(</span><em>matrix</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.matrix_to_marching_cubes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an (n,m,p) matrix into a mesh, using marching_cubes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: (n,m,p) bool, voxel matrix</strong></dt><dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt><dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mesh: Trimesh object, generated by meshing voxels using</strong></dt><dd><p>the marching cubes algorithm in skimage</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.matrix_to_points">
<code class="descclassname">trimesh.voxel.</code><code class="descname">matrix_to_points</code><span class="sig-paren">(</span><em>matrix</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.matrix_to_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an (n,m,p) matrix into a set of points for each voxel center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix: (n,m,p) bool, voxel matrix</strong></dt><dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt><dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points: (q, 3) list of points</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.multibox">
<code class="descclassname">trimesh.voxel.</code><code class="descname">multibox</code><span class="sig-paren">(</span><em>centers</em>, <em>pitch</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.multibox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Trimesh object with a box at every center.</p>
<p>Doesn’t do anything nice or fancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>centers: (n,3) float, center of boxes that are occupied</strong></dt><dd></dd>
<dt><strong>pitch:   float, the edge length of a voxel</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rough: Trimesh object representing inputs</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.points_to_indices">
<code class="descclassname">trimesh.voxel.</code><code class="descname">points_to_indices</code><span class="sig-paren">(</span><em>points</em>, <em>pitch</em>, <em>origin</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.points_to_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert center points of an (n,m,p) matrix into its indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points: (q, 3) float, center points of voxel matrix (n,m,p)</strong></dt><dd></dd>
<dt><strong>pitch: float, what pitch was the voxel matrix computed with</strong></dt><dd></dd>
<dt><strong>origin: (3,) float, what is the origin of the voxel matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices: (q, 3) int, list of indices</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="trimesh.voxel.sparse_to_matrix">
<code class="descclassname">trimesh.voxel.</code><code class="descname">sparse_to_matrix</code><span class="sig-paren">(</span><em>sparse</em><span class="sig-paren">)</span><a class="headerlink" href="#trimesh.voxel.sparse_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a sparse (n,3) list of integer indexes of filled cells,
turn it into a dense (m,o,p) matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse: (n,3) int, index of filled cells</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dense: (m,o,p) bool, matrix of filled cells</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-trimesh">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-trimesh" title="Permalink to this headline">¶</a></h2>
<div class="section" id="https-github-com-mikedh-trimesh">
<h3><a class="reference external" href="https://github.com/mikedh/trimesh">https://github.com/mikedh/trimesh</a><a class="headerlink" href="#https-github-com-mikedh-trimesh" title="Permalink to this headline">¶</a></h3>
<p>Trimesh is a pure Python (2.7- 3.3+) library for loading and using triangular
meshes with an emphasis on watertight meshes. The goal of the library is to
provide a fully featured Trimesh object which allows for easy manipulation
and analysis, in the style of the Polygon object in the Shapely library.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="trimesh.exchange.html" class="btn btn-neutral float-right" title="trimesh.exchange package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="Module Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Michael Dawson-Haggerty

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>